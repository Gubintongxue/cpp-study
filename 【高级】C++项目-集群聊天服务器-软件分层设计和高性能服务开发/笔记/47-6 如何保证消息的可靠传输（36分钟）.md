这节课我们来看这么一个问题，怎么保证消息的可靠传输？呃，这么一个面试问题，我们大家呢？在群里边也反馈了哈呃，可靠传输消息的可靠传输，就是说呢，我这一端这个客户端啊。发送出去了啊，只要我这客户端显示消息发送成功，我就得保证对端一定得收到。要么你收不到，那你客户端就显示消息发送失败，那么用户可能会后续呢选择重新。

去发送这个消息对吧？就跟我们的QQ或者微信是一样的啊，这就叫可靠传输，如果你提示啊，给我提示发送成功了，对端就一定得收到。那我们大家呢？呃，我们的这个同学在面试这个问题的时候呃，他其实呢，第一反应也给出来了，这个问题的解决方法就是。在业务层实现消息的确认机制啊，在业务层啊，实现发送以后呢，

对消息进行一个响应。那面试官转过头来，他就问那你这个项目是基于TCP实现的还是udp实现的哦？我们同学答案是基于TCP实现的。那人家又问了那TCP协议本身不就是一个可靠的传输协议吗他？在发送数据的时候，它有一个数据的超时重传机制嘛，那TCP协议本身大家知道它发送每一个数据的时候都会。呃，这个等待得到接收方返回的一个ack，是不是消息确认啊啊？他如果得不到这个ack，那么他会超时重传。会选择重新发送这个数据啊，得到ack以后，

那就保证这个消息发送成功了，那不是有这个呃，这个超时重传来，确保消息的这个可靠传输的这么一个机制吗？在TCP协议上对吧？那为什么我们业务层上还要去实现这个消息确认呢啊？我们同学一想诶是啊啊TCP协议本身呢，也是可靠传输的。有消息的一个发送以及确认的ack确认的机制，对吧？那为什么还要在业务上实现呃消息确认机制呢？好像确实是比较合理的。那么你这不就是被面试官绕绕进去了吗？其实这个问题呢，你仔细想一想，

我们业务上的消息是不是？能够可靠传输，肯定不能不可能通过这个协议上TCP协议的，这个超时冲传来保证一个可靠传输了啊，你仔细想一想就行了。那到底怎么想？我一会来给大家梳理一下，实际上从这我们就能看到大家在去面试的时候啊，听到面试官的问题。嗯，这个大家思路得转变转变啊，这个面试官问的问题不一定，这个问题都是正确的，我们同学有时候很有意思。心理上呢呃，

去校招去跟公司的面试官去面试，永远还把自己摆在一个学生的位置，面试官就是老师啊，面试官就是权威。人家问的问题我听不明白，是我不行，而不是人家问的问题不对啊，人家问的问题肯定是有答案的，我想不出答案是我不行。不是人家问的问题呃，有毛病。啊，它总是这样的一个形态。你总是这样的一个心态，你永远也长不大。

对吧，你永远也没有办法在社会上去成长，那首先呢，你即将进入社会，或者说大家进入社会。啊，一两年两三年这样呢，再去重新跳槽，找工作的话，再去面试的时候，你首先在心态上，你要有一个正常的心态。你跟面试官，他是对等的啊，对等的包括你在听到面试官所提问的问题的时候呢，

你不用说人家嘴巴刚闭上就必须你得给出答案。你完全可以说哎，你好，这个问题我想几秒钟我梳理一下，在这个梳理的过程中，首先一你先看这个问题提的有没有道理？第二个啊，如果没有发现很明显的瑕疵的话呢，那么在这里边你就总结总结你的思路对吧啊，这个回答的时候呢是？稍微有条理一点，不要太乱，那甚至你还可以呢，带上纸笔或者现场就有纸笔，你在纸上去画一画啊，

画着画着就出来了。好记性，不如烂笔头嘛。有些问题在你脑子里边，你可能一下子踩进人家挖的坑了，你一时半会。出不来，但是你画一画，你可能思路就出来了，可能他提的这个问题本身啊，就是不可靠的，就像我们现在遇到的这个问题。实际上，我们这位同学，如果当时呢，

面试官提问，那为什么不能靠TCP的这个嗯？超时重传啊，来确保消息的可靠传输呢，那他其实在图上画一画，他就知道为什么不能靠这个了。大家来看一看啊。我们来给大家讲一下这个问题。那么，我们先写一个chat clan t吧。哎哎client啊，chat client，然后这个是我们的。chats ever.那么，

大家注意一下啊，注意一下，而我们就看这一段，就是我给你说话，我的消息先发到这个服务端啊，服务端发。再转发给你的话，也是一个网络通信啊，跟我给服务器发，它是一个意思呢，那么我们同学们在代码上是怎么发送的呢？那在这里边。是通过这个send啊，是通过这个send，第一个是socket是不是fd啊，

第二个是什么，第二个是buffer，第三个是什么，第三个是buffer size。第四个是啥？第四个是零。啊，是一些发送选项，我们就直接默认经常就用零就行了，在这里边大家在代码上一般都是判断RET，如果小于零的话，这代表什么？代表发送失败了，这里边我们可能就。exit呢？

或者说是你有其他的一些处理。好的吧啊，那么注意啊，同学们所要注意的第一个点呢，就是呢，这个send啊，它发送成功了。它的返回值没有小于零，发送成功了，返回了，发送成功的字节数，同学们，这个发送成功。并不代表说这消息就跑到对方，对方就接收到了，

并没有说这个。send怎么可能说是我们调用的时候，它还包括了这客户端往服务器发送的这个过程，服务器接收了以后再响应响应成功了以后，我send再返回。不可能的，你要是这样的话呢，那我们这个send可能调用这个接口所花费的时间就特别长了，因为毕竟我们网络。在尤其是网络环境复杂的情况下，这一发送一响应，这耗费的时间是挺长的。那么，同学们首先要注意的第一点是什么？当我们在用户空间，

我们进程的这个用户空间。嗯，大家学我的这个C加加基础课程，我们前几节课就给大家讲了一些呃，能够加深我们语言深层理解的知识就是进程的地址空间。呃程序编译链接原理以及函数的详细的调用对战，对吧？用户空间。的数据就是这个buffer啊buffer。然后呢？他要发送。它是把这个。调用我们系统接口send。它是把这个用户空间的buffer数据呢？拷贝到哪里呀？

各位。拷贝到啊，拷贝到我们内核空间的。拷贝到内核空间的TCP发送缓冲区里面。我们TCP协议在内核里边有TCP的发送缓冲区和接收缓冲区，因为它是一个流失协议，对于uu dp的用户数据报协议，它是没有发送以及接收缓冲区的啊。所以对于我们的TCP发送来说呢，这个发送成功仅仅只是说我们把用户空间的这个八法里边的多少数据。拷贝到我们内核空间的TCP发送缓冲区里边。明白了吧啊，这个拷贝到当前系统的内核的TCP发送缓冲区里边，那这个send就给你返回成功了。那比如说这个buffer里边呢，

放了一个什么，放了一个hello word啊，放了一个hello word，那他如果把这个hello word呢啊，全部的考。拷贝到了从用户空间拷贝到内核空间的发送缓冲区里边呢，那在这里边send相当于就是返回多少一二三四五六七八九十十一。那么你这个buffer size如果传了11的话啊string，那相当于就给你返回值就返回11相当于send了多少11个字节的内容？好吧，如果你呃11+1 string line这个buffer+1，那相当于你把杠零也算上了，那就是12个。对不对？所以send的返回成功，

返回发送成功的字节数并不是它所谓的发送成功，仅仅只是把用户空间的数据拷贝到内核空间的。TCP发送缓冲区里边。那么，这个数据并没有到对端还没有发送到对端呢，然后这里边的这个数据啊，同学们TCP发送缓冲区里边的数据才是由我们内核的。TCP协议栈啊。相当于就是我们TCP协议的这个代码模块啊，来专门把发送缓冲区里边，它有一个滑动窗口机制是吧，可以根据网络状况来调节呢？呃，发送缓冲区里边数据发送的一个。发送的一个快慢的啊，

可以调节这个流量的。把这个数据呢？哎，发送出去。能够明白吧。就是说呢，剩下来的这个发送完全是由内核把这个负责，把这个TCP发送缓冲区里边数据发送出去，你这send只是把用户空间的内容拷贝到这个缓冲区里边。send就返回了，你用户态呢，就继续执行接下来的操作了。所以仅仅只是send函数，没有失败的话，并不能说这个消息就到达对方了。

好的吧啊，那么在这呢，那也就是说开启了什么开启了TCP的传输了啊，开启了TCP的传输了，各位。在这就开启了TCP的传输啦。那TCP传输的时候呢，它传一个报文。它传一个报文。那么。数据传输的时候，先是从这个TCP层传输层到IP层，IP层打一个报IP的报头，再到这个链路层，链路层就是Mark层。

因为链路层是通过发一个Mark帧，一个Mark帧来把数据从这一台主机交换到另外一台主机上的网络层，以上是通过。通过IP地址来定位主机的网络层以下，从链路层啊，在我们实际的链路层，物理层是通过MAC地址呢来定位主机的。那在这里边Mark是真真正正，那就是把数据呢Mark 1帧一帧的数据就发送到这个网络上了。Mark发送一帧的大小上限是个mtu，是个幺五零零个。字节对吧？一般来说TCP的爆头TCP的这个爆头啊。报头是个20个字节，那么IP的报头是个20个字节，

那么一般来说一个这个。网卡的一帧数据最多就携带幺五零零，减去这个40就是幺四六零个字节。当然了，如果说我们发送的数据的大小是大于幺四六零的，对吧啊？那我们在这里边可以进行什么？IP层可以进行分包嘛，是不是啊？可以进行分片传输啊？分片传输以后呢？呃，分成一小片一小片的分成分片传输以后到我们对端来来说的话呢，我们可以把这些小的分片再组成一个原始的数据。好吧啊。

那么，在这里边，大家来看，这是我们设计了一些细节啊。在这我们发送了一个数据包。那在这，因为是我们说的是传输层的，我们直接来看传输层的这个。数据啊，数据报文。你这发送了一个数据报文啊，各位。那么，在这里边有可能出现这两种情况，第一种情况，

那么从这个c端发到s端的话，由于网络的这个情况比较复杂。呃，网络比较拥塞导致的，或者说是呃，网络拥塞的情况下呢？我这个数据报文啊，会经常切换这个。嗯，网络节点的这个路由导致呢？我们这个数据报温的ttl。已经还在没有到达s端的时候ttl，这个就是路由器的跳数已经超过它的上限了。直接被路由器把当前这个数据报文就给丢弃了，也就是说我这个报文没有到达s端，

或者说是我这个报文到达s端了。那么，基于TCP的可靠传输，它对每一个发送的报文段都要进行一个，是不是响应啊？哎，都要得到一个响应，大家来看啊，都要得到一个响应。那么，这个ack可能又碰到了我们刚才的情况。这个ack又碰到了我们刚才的情况，导致什么呀诶导致这个？ack这个报文在网络上丢了，没有到达c端，

不管是我发送的报文c端发送的报文s端没收到，还是s端收到了返回的这个响应，我c端没收到。那都是属于报文传输，什么报文传输失败了，那当第一次发送这个报文的时候呢？tcp协议站里边就会起一个。超时重传啊，定时器。啊，它就会起这么一个超时重传的定时器，那么当我们发送到的这个。发送的这个波纹波纹到达s端s端返回的这个ack也到达这个什么也到达这个客户端的话呢？诶，那我们就可以继续发送下一个报文了，

如果说当我第一次发送该报文。超时这个都已经超时了啊，超时重传定时器都已经超时了，还没有得到这个ack就没有得到s端的一个响应，对端的响应。那么在这里边，它会重启什么？哎，重新你看，就像我们第二行画的这个，重新去发送这个波纹。数据报文。它在力求干什么啊？它在力求呢？这个s端能够呢呃，

给我返回一下这个报文的ack啊，如果呢，后边重传的时候。s端响应了ack，那就说明这个数据报文传输成功了，但是如果还是出现了呃，没有发到s或者s端收到了，发送了ack我客户端没有收着的话。它超过定时时间，它又要进行什么？哎，超时重传，同学们，这个超时重传，它不是说。

s端没有收着的话，它就传一辈子。它超时重传，它是有次数限制的，就跟我们前边给大家讲的这个。TCP协议本身的保活机制的话，它过两个小时呢，它会发一次空爆文的一个探测，对吧？看你活着没？呃，如果你没有响应，它会默认间隔十七十五秒再给你发送，总共发送九次。是不是就表示失败了？

就表示这个链接啊，已经无效了。它这个超时重传也是一样，超时重传，它肯定有超时重传的次数，它不可能无限制的传下去。对不对啊？我们网络情况会很复杂的，那么如果网络情况复杂的情况下啊，搞了很多很多很多TCP的这个报文。超时重传。对不对啊？一直在那不断的冲传，不断的冲传，那我们整个内核所占用的资源永远得不到释放。

这个肯定不是一个好的设计，没有什么东西是一直会持续下去的。好的吧啊，那么同学们在这里边，如果说超过一定次数。重传啊，超过一定次数。啊，在这里边，我们TCP协议上所做的事情呢就是。直接发一个什么，直接发一个rst。相当于发一个链接重置啊，发一个链接重置的这么一个报文给到对方。那整个的这个超时重装的这个流程就走完了。

那这是不是相当于甩手掌柜的啦？那因为PC协议已经给你进行重传了，已经到达重传的上线的次数了，还没有接收到服务端。给我响应了一个ack，那么它只能是。结束了。那你看它是在一定程度上保证了我们报文的可靠性传输，但是呢，如果网络环境比较差的话，那一直重传。都没有得到响应，那最终我们这个TCP啊，响应一个rst这么一个报文，他就不管了，

那相当于消息还是没有到达s端啊。那我们怎么啊？你不能说是仅仅通过这个send成功，只是把用户空间数据拷贝到内核空间，你就给人家用户在客户端显示啊，你的消息发送成功了。客户客户看见这个消息发送成功的提示，以为这个消息都已经到达这个服务端，到达到达对端了是吧？但实际上你在这里边，你的可靠性靠TCP协议本身的。啊，这个超时重传提供的可靠性，那这个如果网络环境有问题的话，那你这数据不是还是传不过去吗？

对着没有？所以我们。聊天消息的可靠传输肯定是不能够保证协议的啊，我们有的同学啊，就是那个同学啊，我还记得，但是具体哪位同学我忘了，我们大家不妨来听一听他的思路啊。我们这个同学呢？当时就问啊老师啊，我们内核的TCP协议站上有没有提供这么一个接口啊？提供这么一个内核的接口是吧？系统API。让我给他注册。让我给他注册一个回调函数啊，

就是呢，他TCP如果说这超时重传到达一定次数。他也没有传成功，他给我把这里边的什么把这里边的回调函数给我调一下，那我应用层我就知道啊，你这个数据最终没有传输成功。同学们啊。你这个你想一想啊。怎么可能？人家内核上还让你用户才提供一个注册函数。对不对啊？尤其是在TCP协议站，TCP协议站这里边呢，是负责网络模块的啊，其本身就随着这个网络环境的。

这个复杂TCP协议栈本身事件也挺复杂的，如果说在这里边给你提供一个注册一个回调函数，那万一你这。回调函数里边访问了一空指针，访问了野指针。你直接把人家内核的TCP模块直接干废了，那怎么办呢？啊TCP，这个协议议站里边给你执行这个回调啊，能保证你传进来的回调函数都是没有任何问题的吗？在这里边不是不可能提供这么详细的，这个回调接口的好的吧啊，不可能提供这么详细的一个回调接口的。那有些同学说linux里边不是有信号吗？是吧signal？

signal signal不就可以提供一个signal handler，这个回调吗？信号的这个回调操作是你当前进程啊，是内核发给你当前进程的一些信号。好吧啊，你这个信号呢？你在处理的过程中，你可以就是写代码，可以让他挂掉，或者你主动调用exit。呃，因为你这个信号对吧啊？是你这个进程的信号。你想把你进程搞挂，那你进程别运行就行了，

因为它最终影响的还是你这一个进程，因为这信号是属于你这个进程的。但是TCP协议站不行啊，这TCP协议站可是给所有的用户空间的应用程序服务的。啊，你这个进程用了网络服务它，那另外一个进程可能也用了TCP的网络服务啊，怎么可能让你注册一个回调，你如万一把这个。TCP的这个内核直接给人搞挂了，怎么办？所以没有这样的一个回调，我们想一想，不可能提供的，如果我们是内核TCP协议站的开发者，

我们也不可能说是给用户暴露这么一个接口，让他注册一个回调。然后当我这里边重传超过一定次数失败的话，我去给你调用这些回调不合理不合理的。好，那么在这里边，那我们最终还是得怎么样啊？我们呢，最终还是要在什么业务上？实现消息的可靠传输。我们就要在业务上实现消息的一个可靠传输啊。那怎么实现呢？简单在这呢，我们再画一下啊，再画一下那么。

同学们在这里边是chat client。那这边还是？chats ever是吧？chats ever.那在这里边当我们啊，当我们。我们不是。要发送的消息啊，我们clan t在这里边。客户要发送的消息。啊，都缓存起来。为什么要缓存起来？因为我们客户端要实现这个消息的可靠传输嘛，缓存起来，

它每一个消息不都对应有一个什么？我们前面说了，是不是一个？序号啊。啊，我跟你聊，我跟他聊一对一的聊天，或者我在群聊里边聊天，每一个对象啊，我在每一个聊天的这个会话里边啊，都有一个消息的sequence消息的编号。那么，当在这里边啊，你看。我说话的时候。

嗯，比如说是这是user ID。这是张三啊。或者说是我们简单点啊，就直接说消息吧。message 1。这是什么东西呀？sequence是个几啊？是个零。我在这连发了三条消息message，1 message，2 message，三那这三条消息的这个序号分别是零一二。对吧啊，那在这里边呢，

同学们来看，那我们就要开始去发送这个数据了。这个数据先发送出去。发送出去以后按正常的这个结果来说，我这个业务上要等待什么，要等待你服务端。啊，对我这个消息的一个响应ack。就是我收到你的消息啦。对了，没有然后呢？从正常流程上来说，我就开始发送第几个消息啊呃，下一个消息。好吧啊，

就发送下一个消息。或者说在我客户端这一块啊，也没有必要按照顺序发啊，为了它的一个啊，性能来说的话呢，我可以把这个消息怎么样？我可以把这个消息呢，全部给它先发送出去。因为我们前边说了嘛，这个只要每一个消息都有一个sequence，它在对端收着的时候会按照这个sequence进行一个。呃，进行一个这个编号呃，按顺序是不是来接收这个消息的啊？所以在这里边我们发送方，

我们直接可以全部发送出去。但是我们一定要等待每一个消息的什么，每一个消息啊，对方给我们回应的ack。哪一个消息回应了ack，那我们就说明哪一个消息真的是可靠传输，传输到了对端。那同样的传送到这个服务器，服务器再向。这个是甲啊，再向乙传输的时候是不是还是这么一个道理啊啊？还是这么一个道理？那在这里边，因为每一个消息，它都有一个编号。

对吧啊，都有个编号，所以这里边响应你是对哪个编号的消息进行响应的，所以这都能区分出来，你就像这个。这个是。我from。啊，这个。给谁传输啊？给张三传输这个sequence是个几啊？sequence是零。啊，那么到时候呢，响应的话，

它也是呢啊，响应这个叫消息的是响应是吧啊？那我我我也可以把这个。消息都带过来。啊two。张3 se q0这消息类型就是一个，比如说message type。哎，message type。type它就是个啥呀，它就是一个message ack，就是确认消息相当于对零号消息进行确认。如果确认到了哦，我们本地的缓存就可以把这个消息怎么样啊？从本地缓存我们删掉了，

那就说明了这个消息后续不用发了啊，这个也确认了。如果说我们得不到chat server，对于一号消息的一个确认的话呢，那在这里边，我们在业务上也可以就。就实现了什么啊？如果说在这里边，我有一个三秒钟没有收到响应，我在这里边再怎么样？再重新去发这个消息。再重新发这个消息。啊，如果三秒钟还没有响应的话。我可以继续怎么样发这个消息？

重复三次。重复三次，如果在这里边没有发送成功的话，我们就判定呢，我们就可以给客户端显示显示什么该消息发送失败了，就打一个红叉。我们在QQ，微信上经常见到的，对吧？等下一次网络恢复的话呢，我们。就是由用户来选择在这里边点这个呃重发，我们重新发这个消息。相当于每间隔三毫秒，我们发三次，

这个由可以由我们应用程序自己来定。明白了吧，这样一来呢，我们就可以得到一个消息的可靠传输了，我们在应用层上才能真真正正得到。啊，这个消息到底有没有到对端？好吧啊，仅仅只是通过协议层的这个超时重传，我们这个消息呢，是没有办法完全保证。呃，消息是一定会到达对端的，因为这个重传也有可能一直是失败的。我们前面不是给大家讲过吗？

这个c端到s端。我们是有发什么东西的，有发心跳的嘛，用来检测我们对端是否存在嘛？是不是前面我们给大家讲的时候是讲了s端检测这个c端，这个在不在s端呢？维护了每一个c端user ID的一个sequence是不是？其实c端也是一样的嘛，c端它也有一个，就比如说hard beat，hard beat cnt啊，它刚开始是零。对不对啊？他发一个心跳，他加个一收到这个服务端心跳的响应，

他减个一那基本上来说呢，就是在零一进行时候徘徊呀。发一个心跳，加个一服务端响应的话，它就减个一到零，那相当于这个可以通过心跳来检测客户端。来来，在客户端这里边检测服务端这个链接到底能不能连通？是不是啊？那如果心跳都是正常的，在这里边我们发送消息呢，肯定都是没有问题的啊，如果在这里边我们检测心跳，比如说我们超过了。三秒或者超过四秒或者超过五秒啊，

因为呢，我一直隔一秒发一心跳，你服务端没有响应，相当于我在这里边从零加到一，下次再发心跳，再加一二，再发心跳，再加一三。超过三了，以后我就判定了跟客跟这个服务器怎么样？断开了我这个客户端，可能在这里边就不是一个绿色的状态，而是一个红色的状态了，就表示现在跟服务器。啊，

网络原因跟服务器已经断开连接，很有可能我们服务器，比如说是半夜在那升级呢，或者服务器呢，剪辑给挂掉了，我们之前钉钉啊啊，企业微信啊，都出现过这样的，就是白天工作时间。啊，直接就给断网了，40分钟一个多小时，对吧？这就是由于呢？后台的某些服务给挂掉了啊，

或者说是流量太大，后台撑不住了。那么，这里边我们都可以通过这个心跳来检测出来客户端跟服务器的一个通信的状态，如果说这个心跳啊，那我们这个呃。这个客户端。啊，就一直是怎么样啊啊？就一直发这个心跳，我们检测啊，如果我们用户没有退出，我们这个APP的话，我们就一直发心跳。如果呃，

发着发着等一会呢，这个网络恢复了对吧呃，我们客户端发了一个心跳服务端怎么样？呃，服务端我们响应了，那在这里边，我们可以把刚才的三给它重置成零。是不是啊？再发一次加一啊，响应一次减一，如果刚恢复了又发生问题了，那相当于我发送心跳服务端又没回了。加一+2+3，是不是又判定跟这个服务端？网络有问题，

无法连通了，哎。也就是说，心跳这块给我们客户端这里边给了一个状态，跟服务器的一个连接状态，在这里边当我们发送消息的时候，其实我们可以先看一下这个状态，连接的状态OK认为。如果OK的话，心跳消息都能交互成功的话，我们发送普通消息也肯定是可以收到什么的。哎，受到这个ack的好吧啊，如果心跳在这里边已经心跳失败了，我们全局的有一个状态，

就是跟服务器的状态已经。是不可用的状态。inactive的状态的话，那我们客户端在这发送消息，我们就直接不能发送，或者说是直接给用户显示发送失败就行，不用尝试发送了。心跳都失败了，你发送消息能成功啊，等下一次心跳恢复正常的话，我们再去发这个消息就可以了。能够明白了吧啊，所以呢呃，这个。啊，

我就给大家这个问题，就解释到这里边，而实际上呢，我们在呃线网环境中的产品啊，基于长连接的这种。TCP传输啊，我们经常会加上心跳机制，包括呢，不仅仅是TCP，包括我们udp。包括udp。udp 1般用来呃像传输一些音视频啊，对吧？允允许一定程度上的一些丢包丢帧的话。udp的效率相对来说还是能高一些的啊TCP呢，

不管是TCP还是udp，我们都可以是通过心跳机制来。这个复杂的线网环境中来检测服务端，检测客户端是否在线啊？这客户端检测服务端是否链路是否正常？行，那我说到这里边，大家应该能够了解这个问题了啊，就是。怎么保证消息的可靠传输？业务层实现消息确认机制，那消息确认再结合这个心跳。那么，在这里边为什么TCP的消息确认机制不能保证消息的可靠传输？你看你在这里边稍微画一画那。

这个。这个这个在不好的情况下，在最坏的情况下啊，那我们这个超时重传都有可能失败的。对吧，那你send接口返回成功，只是说明用户空间的buffer拷贝到内核空间，这拷贝成功了。但是又没有保证对端收的到，那我send返回一个大于零的数，那我再给给用户显示的时候，我到底是显示这个消息发送成功还是发送不成功啊？我用户他我我又没有办法去监听到TCP底层的这个数据啊，到底是超时重传成功了还是超时重传最终失败了，我也不知道啊。

对着没有？因为这个s in它，它代表不了这一块的状态啊。send只是能代表本机的这一块的状态，拷贝数据，拷贝的状态。代表不了这块的状态。所以我们要实现消息的可靠传输，肯定还得在业务上实现消息的可靠传输。行，那我这个问题就讲到这里边，希望给大家带来更多的一些思考啊，那我们嗯。能够举一反三，对吧？

讲一点，大家可以开阔一下大家脑子的思路，可以延伸出更多的点去想一想。这个我们在复杂的网络环境中，如何做一些可靠的消息传输，我们无非就是做了一个m的聊天消息。大家在应相应的场景下，可以想一想我们QQ好，微信是如何做这件事情的？行，那这个问题我们就给大家讲解到，这里如果还有问题的话呢啊，大家可以在QQ上进行一个反馈啊。