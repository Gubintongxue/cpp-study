这节课我们来看一下这个项目。另外一个问题就是客户端消息如何按序显示？不是按时间啊，是按序。按序也可以按时间顺序吧。啊，按序显示啊，按序显示就是我跟你说话，我这段我这边是怎么发的？啊，我前后两条或者三四条，我是什么顺序发的你你那边接收也是什么样的顺序接收？明白吧啊，不管是一对一聊还是在群聊里边都是这个样子的，对于某一个人来说，

他在自己的客户端。呃，他先发了hello world，再发了hello China，那么不管是到谁那边，是在群里边，还是在个人一对一聊天界面里边，应该都是先显示hello world第二个，再显示hello China。没问题吧？那实际上这个问题呢，我之前看大家在群里边都讨论很多了啊。嗯，也没有机会给大家详细的去说一下呃，那刚好我们这节课就主要来把这个问题说一下。

我我们直接来说，他说很多同学呢，说给消息加一个时间，我们现在呢，在实现上确实没有保证这么一个。消息按顺序到达，因为我们都是局域网的一个聊天嘛，对吧？局域网的话，这个网络环境没有那么复杂，所以它不会出现。基本是不会出现。小许，这个乱序到达的啊，基本上都是按序到达，

但是如果是一个真实的环境的话，我们是要做一个产品线上的产品，是要给广大的，这个中国或者全球的客户来使用的话，这个功能我们肯定。得实现了啊。嗯，要不然呢，你发的时候是按前后顺序发的，到我这边是按这个乱序显示的，可能意思完全就改变了啊，大家自己脑补一个场景。这里边大家给出的这个解决方案是添加一个给消添加一个时间。那么我先说一下大家的疑问啊，给消息。

添加一个时间戳。那么。这个是甲。这是客户端啊。这是我们服务端。这是服务端。server.那我们消息呢，是要通过这个服务端在这里边进行转发啊？好，既然把这个图已经画出来了，我在这我顺便说一个简单的，我们同学们之前在圈里边讨论过的问题啊，就是我们的这个聊天服务器为什么要实现成一个长连接短连接行不行？短连接。

就类似于我们HTTP协议。它是一个应用层的协议，它底层也是依赖TCP来实现的。但是呢，我们客户端。就是浏览器跟服务端啊BS结构进行交互的时候，我们浏览器永远是发送一个请求到服务端。服务端处理完这个抢求，给一个response响应，然后服务端会主动的把这个连接会关闭掉，然后给其他的更多的客户来提供服务。OK吧，这就是一个典型的短连接，无状态的这么一个协议。这种无状态短链接啊。

无状态。短链接。它的这个服务的模式只能是客户端主动请求服务端被迫营业。被迫营业，也就是主这个被迫响应。好吧啊，服务端是没有办法。去给这个浏览器主动推送消息的，那你像我们这个登录像淘宝还有京东，那不是有这个淘宝旺旺京东上是不是也有？聊天消息啊呃，也能收到对端推送来的消息，这其实都是通过web socket。技术在浏览器和服务端创建了一个TCP的。长连接。

才能够。呃，让服务端服务端给我们客户端主动推送消息，我们这是一个聊天业务啊，对吧？甲跟乙聊甲的消息先发到这个服务端服务端，然后再找到乙，然后主动推消息到乙。服务端是要主动推消息的，你不建立长连接，你服务器怎么知道跟乙通信用的socket是哪个呢？连接你都找不到服务端，怎么给乙推送消息？难道让乙自己去隔个十毫秒，隔个这个100毫秒主动的去服务器上拉一下，

看有没有我的消息，有没有我的消息？那这里边有1100万个客户，每个客户都每隔十毫秒去拉一下自己有没有消息，那是不是大部分拉都是白拉了，都没有消息？那你这样服务端来说的话。处理的请求实在是太多太多太多了吧。对于这种我们支持m消息。im消息啊，及时聊天消息，及时聊天。消息功能的这个服务器来说，这个设计肯定是要跟客户端保持一个长连接，我们服务端都会有专门有一个长连接模块。

啊长连接模块。长连接模块专门保存了所有客户端建立的这个长连接所用的这个连接消息啊，连接消息内容里边包含了跟这个连接用的socket fd啊。还可能还包括一些其他的统计信息，比如说连接的时长啊，对吧啊，连接的这个通信的频率啊这。那之类的啊。那么，在这里边，所以我们肯定这个项目得用长连接啊，对吧啊？你就说。这个服务器要推消息嘛，到客户端啊，

不推的话只是被动营业的话，被动响应啊，我们这个客户端只能是隔一段时间去服务端去拉了，那隔多长时间呢？你肯定不能隔的太长，隔的太长的话呢，客户端啊，这个消息显示是不是非常延迟啊？你要一个客户端，你每隔一段时间拉100万个，甚至1000万个客户端都去拉的话。那这个服务器你觉得能承受那么大的一个请求吗？肯定是不合理的嘛，所以。长连接是没有什么问题的，

对吧？那在这回归到我们这节课所要说的问题。那在这里边啊。我先甲先发了一个。甲先发了一个，你好吗啊？你在吗？对吧啊？你下午有什么？打算是不是啊？就发这两条信息，那我原来都是。明文呃，原来都是明文传输，而且呢，

没有任何的这个时间戳。啊，大家现在想打一个时间戳行在我们这个客户端啊，这个可能是23点。这个十分零一秒。这个可能是。23点10分零五秒。好吧，那么同学们在这里边，当我们这个甲这个客户端啊，把消息从网络发送到服务端。那么，首先，同学们这就叫设计真实的网络。真实网络环境，

我们客户端跟服务器。发送的不同的消息，从我们甲这个客户端路由到这个服务端都有可能经过不同的这个网络节点的。啊，也就是说在不做任何控制的情况下啊，甲这里边先发的，你在吗？先发送出去。你下午有什么打算后发出去，那么到达服务端一定是这一句话，先到下一条消息后到吗？这个还真不一定。有可能你在吗？这句话这句消息先发，但是他选择的这个网络的路由节点，

我我有很多节点路由器的是吧啊？经过本地的经过运营商的啊。到我们的这个服务端，那么经过的这个网络节点可能比较拥堵，所以呢，这个在网络节点上停留的时间比较长，而这个你下午有什么打算这个？根据我们网络的路由算法选择的这个路由节点可能比较通畅，可能更快的到达了这个服务端，是不是啊？那么也就是说，到达服务端的时候呢？有可能就是这个先到达的。啊，这个后到达的是不是那么服务端，

然后接收分别接收这两条消息的时候会把这两条消息是不是给我们以这个客户端进行一个转发呀？那转发的时候同样会遇到我们讲这个客户端往服务端发送消息所经过的所选择的不同的路由节点，不同的网络拥塞的情况。还会遇到同样的问题的，那么也就是说他有可能先发的这个，但是后到的乙也有可能是。啊，先发的这个，这个就先到了，任何情况都有可能的，对吧？那么大家现在就是为了考。考虑异常的情况，所以我们在这里边考虑的时候就考虑啊。服务端转发给乙的时候也是这样，

那乙在这里边，如果按照接收的顺序直接显示的话，乙的客户端会先看到诶。这个是23点10分零五秒，说了一句话，怎么还给时间倒流了，接下来又搞了一个23点10分零一秒，说了一句话，这肯定对于乙来说，对于客户的使用感受来说。肯定是不行的，有可能。说话的意思都改变了，至少在我们这儿，你下午有什么打算？

你在吗？可能意思没什么大的问题是吧？那但是这个。但这个时间显示肯定是有点问题的，那么同学们给的这个解决问题就是给消息加一时间戳。到达客户端的时候，按照这个时间戳进行一个排序，然后再显示。那么，同学们，这个解决方法。它是有瑕疵的。首先，我们网络上随时会发送过来消息到我们客户端，那你客户端在进行排序的时候，

你肯定得有一定的时间。时间间断吧，比如说我一秒内接收到的消息，我不给客户端显示，这一秒内。接收到的消息呃，我以一秒为周期进行消息显示。一秒为周期。啊，进行这个消息显示。那么，当我显示的时候，我就把这一秒之内接收到的所有的消息按照时间戳，怎么样排个序可以吗？当然可以，

但这里边依然是有问题呀，你是以一秒为周期进行消息显示的啊，那假如说。在这里边这两组消息刚好是跑在了一秒的周期之内，那一秒过了一秒钟显示的时候，这两个一排序肯定是能够把这个显示在前。是不是这个显示在后啊？但是呢，在这里边同学们啊，这里边还发了一个消息嗯。下午走去打篮球。啊，怎么样？诶和怎么样？那假如说这个是23点。

十分15秒说的，然后通过网络发送出去呢。在服务端是这个在。在这里边，你看在客户端啊，在客户端就是后收到的啊，他先收到这个，再收到这个，再收到这个啊。那如果在这里边啊啊，我举的这个例子不太合适啊，举的这个例子不太合适。嗯，那么我重新举一个啊。按照它们的顺序来看一下。

那也就是说呢，在这里边啊，是这一个。消息跟。谁啊？跟这一个消息。先到达了。啊，这两个消息先到达了是吧啊？这两个消息先到达了。然后你再骂这个消息呢，由于网络拥塞啊。这个后到达了，这是非常有可能的，是不是啊？

这是非常有可能的啊，在这里边我们可能这里边写的时间差的比较大，比如说这是一秒，这是。零二秒，这是零三秒对吧啊？很有可能就出现这样的一情况，那么同学们，我在这里边，我们把问题场景给大家列出来就可以了，在这里边我主要说的是。你在这里边按照时间戳进行显示的时候啊，你没有办法在全局对时间戳进行排序。因为在这里边，你按时间戳。

啊，按时间戳进行显示的话呢，你在这里边只能规定一个周期，我把这个周期内的这个消息呢，按时间排序，那么如果这两个消息处在一秒的时间周期之内。而这几个消息跟后边这个消息处在不同的时间周期。那你只能保证是这个时间周期之内消息显示的时候会进行什么会进行消息按时间戳排序，但是这一组消息的显示跟下一组下一个一秒周期内接收到的消息的时间戳。会排序吗？不会排序，那么你显示的时候还是零五显示幺五显示再显示零一，这个是不是还是？不好的。还是会有问题的呀。

好的吧啊，那么也就是说呢，解决这个问题，其实呢，我们最好的方法并不是时间戳，而是。给给每一个消息都。添加一个。序列号。就是sequence。比如说我可以从零开始。一二三四五六七八九，就这样。好吧啊，就这样。

那么同学们，你看看。那在这里边。当我甲给乙进行消息发送的时候，来同学们，我刚把这块已经给大家讲了呢，那我们这就先去掉啊。大家注意一下，你要是想看的话，可以把视频倒这个往前拉一点啊，我们这就先截掉了。那么也就是说，现在甲在这里边发送消息的时候，每一个消息呢？除了消息内容就是我们原来携带的那些内容本身。

我们这每一个消息还携带携带了一个sequence，因为在甲这个客户端甲是先说你在吗？这句话的，所以。所以这句话呢，在这带的sequence就是零。好吧，然后他才说你下午有什么打算，这一句消息带的sequence。这是一，这是按照它们的先后顺序来的嘛，那这个sequence就是什么？就是2 OK吧好。那么，同学们啊，

在这里边。这里边进行发送的时候你不管啊，你不管到服务端它接收的顺序是什么？啊，不管到服务端接受的顺序是什么？你看嗯，哪怕就是现在的这个顺序。这个上面是谁啊？上面是一。这下边是二是吧？好，那么同学们来看一下。如果呢啊，我们服务端是这样接受的啊，这样接受的这个顺序没有做任何的要求，

没有关系，那么服务端先转发这个。转发这个消息到我们乙来以后呢啊，乙是不会显示这个消息的，为什么因为乙这个客户端在这？维护了每一个好友的消息sequence。也就是说，他现在维护的甲的sequence初始值是零，也就是说呢，乙下一次在接收甲的这个消息的时候啊。它首先需要接收sequence是零的这个消息。那么，现在乙接收甲的消息了，查了一下他维护的甲的sequence消息的序列号是多少是零，但是呢，

他发现接收的甲的消息现在这条消息的序列号是一。那就证明了。不能先显示这个需要把这个消息先怎么样哎，先缓存到客户端本地，你的客户端本地。然后呢？可能服务端转发的这个消息，这条消息又先过来了，那么乙在显示呢？这条消息的时候同样的这是甲这个人发过来的消息。那么，他首先查看一下甲这个人，他本地维护的甲这个人啊，下一次收到甲消息的序列号，期望应该是几零。

但是现在是二证明，这也不是我要显示的假的消息，应该先怎么样缓存起来？然后再如何啊？如果这条消息发过来以后。哎，我看到的这个是甲发过来，而且他这个消息的序号呢？跟谁啊？跟我本地维护的，对于甲这个人下一次要发送的消息的序列号是？吻合的匹配的，那么这条消息就应该怎么样先显示，然后sequence+1在原来的基础上加一？然后他会在看有没有本地缓存，

有本地缓存的话，在本地缓存里边找到有没有sequence为一的。假的消息有，有的话继续给甲显示这条消息。好，显示完消息以后sequence再加个一就变成二了，然后在本地里边再找有没有假发过来的消息sequence是二了，有有的话就显示。对吧啊，显示完了以后再加1 sequence变成三那变成三了，以后呢，在这里边他发发现啊，本地缓存里边已经没有sequence为三的假的消息了，那这里边相当于。甲的消息目前为止已经处理完了，

那就等下一次甲发消息继续嘛，下一次甲发的消息过来，你看甲再发一个。时间到了。准备出发。那这个sequence。是不是应该是三啊？对着没有这一对一一对一，这是甲跟乙在聊啊，甲跟乙在聊，甲跟乙在聊的话。这是一对一的聊，或者甲在某一个群里边聊，在某一个群里边聊都要针对啊，某一个人。

或者某一个群维护一个sequence。好吧啊，这个不是全局共享的，这不是全局共享的，我不可能说是甲跟乙说话，甲跟丙说话，用用一个sequence，这不可能啊。对吧啊，这不可能的，不管是甲跟呃一对一的聊天，还是甲在某个群里边说话，那么在这里边本地。还有对端都维护了啊，都维护了，

在对于这个人对于这个群啊，我当前发的消息的sequence。是个几啊？好的吧啊，方式三三到了的话呢，那在这里边发到这个服务端，服务端又转发到这个乙的客户端，乙的客户端发现接收到了甲的消息。啊，sequence是三跟我记录的维护的啊甲这个人，下一次我期望发送的消息的sequence是三吻合，那就直接。显示了。这样一来的话呢，你消息肯定是不会乱的。

好的吧啊，消息肯定是不会乱的，而且每一个消息有了序列号。不仅仅可以保证。不仅仅可以保证。消息的按序到达。更重要的还是可以实现，还可以实现。其他更多的功能。哎，还可以实现其他更多的功能。对吧，比如说你打时间戳，你就没有办法完成一个功能啊，我用序列号我就可以完成。

完成什么呢？同学们啊，大家经常聊天的时候说话有点打错字了啊，说错话了。都要进行什么消息撤回？是不是实现消息撤回啊？那如果每一条消息没有标记的话，那消息如何撤回？没有任何标记我甲。是不是啊？突然有事了，我下午打不了篮球了，那我刚给乙发问乙打不打篮球，乙要万一打的话，我又去不了，

不太好，所以我要把这个消息撤回。你这个消息没有任何的标识的话，你怎么撤回的嘛？你在乙这一端，他就没有办法去识别，下午去打篮球怎么样这一个？消息的是不是身份了，没有办法识别啊，我们现在有序号了就好办，因为我们在客户端这里边每一条消息都有一个序号，当我甲在这里边发起对这条消息进行一个撤回的话。那相当于就发了一个撤回消息啊，发起人是甲，接收人是消息，

接收人是乙，对不对？撤回的消息的序列号是几啊？序列号是二，那么这个消息呢？发到服务端，服务端再把这个消息转发给谁？哎，把这个请求转发给这个乙的话，哎，乙在这里边就知道了哦。甲要撤回，是不是sequence 2的这个消息啊？哎，他就在这里边找见。

sequence是二的消息，你看每一条消息都有身份了，然后把这个消息呢，从以这个客户端显示界面给它剔除掉。是不是相当于就是实现消息撤回了，相当于给每一条消息都打了，都打了标志。啊，都打了一个身份啊，实际的像这个企业微信政务微信，它都是这么实现的。啊，实际上都是给消息增加一个字段，但在这里边是增加一个序列号。好的吧，

同学们注意一下啊，其实增加时间戳，这时间戳这个东西呢，实际变数是非常大的，因为。对于这个服务器来说啊，服务器来说，那我们集群的话，每一台服务器，它的时间可能不一样，对于客户端来说，客户端有可能自己修改自己的时间的。修改的不是当前准确的时间，虽然呢，这个现在啊，

不管是包括客户端还是服务器都是联网。都不断的去请求时间服务器来保持时间的统一，但是呢，用时间戳来。保证消息的顺序显示，它还是不可靠的啊，还是不可靠的，我们刚才已经给大家说它的一些弱点了，用序列号。啊，才是能够真真正正，不管是在什么样的网络环境下实现我们消息顺序显示的啊，这么一个根本。当然在这里边呢，我们也会存在一些问题，

因为大家知道每一条这个。每每一条消息，最终通过我们TCP啊报文封装，然后再打打打包成ib的报文IP报文里边字段有一个ttl。就是嗯，最大。就是最大的这个跳数。因为我们这个消息在网络节点上经过一个路由器，它相当于增加了，就是跳了一次，经过一个路由器就跳了一次ttl，这里边我们通常是64，那么如果相当于就是说你这个服务端。这个转发消息到这个客户端乙的话，如果这个消息呢啊？

跑跑的这个。嗯，经过了一个路由跑的这个节点，路由器的节点过数好超过64了，那这个消息相当于就直接被。挑到某一个路由器上了。好某一个路由器上了，路由器上了，路由器首先给这个消息的，这个ttl+1。发现加一完了以后，这个当前这个爆文的ttl已经变成65了，对着没有啊？那他就认为呢这个？消息不应该在网络环境里边再存活了啊，

他要把就是这个路由器就直接把这个网络消息呢，就怎么样？就直接就干掉了。就丢弃掉了。把这个网络消息就直接丢弃掉了，那丢弃掉了以后是不是导致我们以这个客户端在这里边本地缓存了一跟二的消息，永远也拿不到什么？永远也拿不到，是不是sequence为零的这个消息呀啊？当然这里边实现机制就比较多了，你可以主动的向这个服务端。发起消息啊，发起消息一个可消息的可靠传输嘛，这个我们是另外一个问题，后边会给大家说啊，

然后服务端呢，再请求甲把这个sequence为零的消息再重发一下。好吧，如果乙在这里边重试了三次，都没有办法去得到乙发过来的sequence为零的这个消息的话，那我们就判定这个消息。是没有办法发送成功的啊，没有办法发送成功的，对吧？那在这里边就接下来直接显示一跟二就行了。并更新sequence为几啊，并更新sequence为三，这个很常见吧，大家在聊QQ的时候，有些时候呢，

网络环境比较差的话，我们QQ。也会碰到啊，有人说给你发消息了，但是你确实是没有收到这种情况，消息丢了。对吧啊。好，那么在这里边大家注意一下，这就是我们给大家讲解的，如何保证消息到达，而且我们有了sequence，还可以实现诸如消息撤回这样的一些。呃，功能。

至于一些小的细节，像这sequence刚开始啊，我们刚开始使用的话sequence呢，不管是甲跟乙，甲跟丙还是甲，在某一个群里对吧啊？甲跟这个顶之类的无所谓啊，你sequence可以默认啊，这边发起方第一条消息就是零，这边接收掉的。接收到的就是以这边维护每一个客户端的啊，这个sequence都是零后边呢，你随着聊聊天，这个就是加嘛，你这个。

发一条消息sequence去加个一，这边收着一条消息就期望的下一次期望的消息的sequence是不是也加个一啊啊，比如说做一个长整形。呃，做一个。做一个整形，这个sequence呢？用一个无符号的整形就行了啊，用无符号的整形就行了unsigned int。那么，无符号的整形可以它的取值范围上限可以达到40亿，那也就是说它从零一下增到了40亿的这个消息数量。你还可以。ned，浪浪。

64位无符号，64位的哇，那这个就是非常非常非常大了是吧啊，没关系。几就是你聊的消息特别多，聊了好几年啊，是吧哈好十几年那你这个上限达到了上限达到了那？对于它的这个无符号的上限值，再加个一，它本身不就变成零了吗？它就在它的这个范围内，是不是进行循环啊？啊，这没有关系的，不影响什么，

大家细节处，大家可以自己。想一想好吧，这个不影响的，因为有些同学说啊，这个C语言一直加加越界了，怎么办？加越界了，从很大的一个数又变回零，那又咋了嘛？那你在这变回零，他下一次他这个sequence发完这个消息以后，他已经是这个on sun的浪浪的最大值了，他下一次再发消息的话，他拿sequence+1，

他也不也是返回来又变成零了吗？那你这边期望的也是零。这两端匹配就行了，它越界它肯定也越界了呀，它们越界以后都是从最大值变成零又开始了嘛。这不相干的好不好啊？大家呢？就是想问题可以自己多模拟模拟，多画一画啊。行，那这个问题我们就给大家嗯，这个讲解到这里，希望能够给大家带来一些思考，可以就着这个问题再想一想。嗯，

相关性的这个问题，因为好多同学他面试的时候没有给我上报一些问题，那你在心里边还残留的那些没有办法解决问题，跟这个问题是否有相关性呢？看能不能解决啊，如果没有，还有啊，没不能解决的问题的话，大家可以在QQ上来问我吧啊。可以来随时来问。好，那我们这节课就给大家先说到这。