这节课我们来继续看一下这个问题，如果网络拥塞严重，chat server端如何感知客户端在线还是？掉线了。同学们来。看一下这个面试的问题，因为我们现在呢？我们先画一下啊，先画一个客户端出来，这是一个。Chad clan t.这是一个chat server。那么。我们现在啊。它是怎么去感知客户端下线的呢？

chat server.同学们，想一想，项目上现在你是怎么感知客户端掉线的？项目上现在感知客户端掉线啊是。在这里边。客户端主动通过什么？主动通过。相当于就是close fd。啊close fd那发送什么呀？那相当于就是TCP四次挥手了嘛。对了，没有啊，直接发发送了这个FM包了啊，发finish包了。

就要进行一个挥手操作，然后。对于chat server这一端呢那。它就会有一个响应。就是receive它返回就是什么？就是一个零了。我们receive的话，返回值就是个零啊，就判断呢，判断这个client这个。掉线了啊，或者是c下线了。对吧啊c下线了，这就是我们在局域网的这个聊天服务器里边，因为网络情况良好的话。

那这是没有问题的啊，几乎是不会出现，说是我们客户端发了1 finish包，我们局域网收不着。对吧啊，局域网收不着。在这里边大家注意一下啊。但是如果放在真实的网络环境里边啊，真实的网络环境里边，那这个chat client。发送的这个finish包有可能啊，我们服务器根本收不着，为什么因为真实的这个网络环境，它网络是非常非常复杂的。有可能呢，

现在啊，我们chat client到chat server中间的这个网络节点路由器，它里边的报文非常非常多，网络拥塞非常的严重啊，导致呢，我们finish包呢，过不来。到到不了这个chat server。当然了，有些同学说TCP是可以呃发送的，每一个包都会嗯去。都会去呃，等待这个包的一个响应的，对吧？它如果没有响应的话呢？

它会继续超时重传。是的啊，但是它超时重传也有一定的次数。它超过一定的次数，重传的话都没有受到响应，那么在这里边呢，它就会。reset了，它就会重置了啊，它就会重置了，相当于那不管怎么样，那你这个finish包最终还是没有到达chats ever了，所以最终导致的就是说呢呃check clt。已经下线了，但是chat server并没有感知到。

很有可能就会碰到这样的情况啊，这是如果我们这个项目作为一个线上的项目啊，给我们全国甚至全世界的。这个人来使用的话，那这个问题我们不得不考虑啊，这个问题我们不得不考虑。那在这里边，其实呢？这个应该是很简单啊，这个很简单，我们在群里边，我们同学们去问的时候，有的同学其实已经给出。这个自己的答案了啊。其实这个问题就是我们经常在CS模型客户端服务器模型里边经常给出的一个。

心跳心跳机制。心跳机制心跳嘛，大家顾名思义就是。一会儿交互一下，一会儿交互一下，就跟我们的这个心跳一样，它有一定频率的在跳动，在交互。那一般来说，我们实现的时候，实现的方式很多，比如说我们的这个chats ever，我们listen在。8080端口对吧啊，是一个。

啊TCP的这个端口，当然我们不同协议可以绑定同样的端口，比如说我们有udp。创建一个udp这个啊，socket也绑定在8080端口。好吧啊，这个类。point啊，这个listen 8080端口啊，这是专门干什么？专门处理我们的业务端口嘛。就是专门接收我们发的这个json的这个数据的啊，来处理业务的udbsocket这个主要是什么端口啊？那我们把它。心跳应该是心跳业务处理。

这个是我们普通通用业务业务处理。通用业务处理。好吧啊，那可以这样设计。当然了，在这里边我们这样设计以后。那也就是说。我们服务端。会给每一个啊，会给每一个。connect成功的。客户端啊，分配一个。心跳计数。就比如说。

拿这个user ID啊，user ID是张3，user ID是张三，它的一个。heartbeat.hard b的这个次数呢？刚开始都是零。它对每一个账号，它都有一个登录成功的账号，都有一个这个。心跳计数啊，这里边。大家来看看。他这个心跳的具体的思路是什么？有些同学明白，

有些同学不太清楚这个啊，那是这样的。就是说。那么，服务端在这里边会起一个通用定时器。启动启动一个心跳计时器，这是计数器啊，或者是计时器啊。这个是在我们服务端启动的，这是在服务端启动它的功能很简单，比如说是嗯。超时一秒。统计了超时一秒，就把所有的这个。所有的。

所有账号的。心跳计数。加一那也就是说过了一秒以后呢，在这里边给原来的这个账号的心跳计数都加一从零变成了一。好吧啊，那再过一秒再加一就变成了二。再过一秒，再变成三。就这样。如果。账号的心跳计数啊，心跳计数。超过比如说。超过五。就判定。

这个clan t。已经掉线了。那么也就是说呢？我们服务端。在监听一个客户端。五秒之内都没有任何心跳的话。那就判断这个客户端就关闭了，关闭了以后呢就拆除。那就是拆除。这个clan的客户端所有的。连接。以及。其他资源相当于就是这客户端下线了。那有的同学说你这里边光加肯定会超过五的，那有加当然会有减，

每一个客户端。每一个客户端在这里边，每一个客户端啊，每一个chat client啊，在这里边它每隔一秒。都会去发一个什么？就跟我们心跳一样嘛，每隔一秒都会发一个心跳消息的。这是肯定的，对吧啊？这是肯定的，那在这里边呢我们。前边的这些业务呢，都是通过TCP socket来跟我们服务端进行一个通信的啊，那这个心跳为了不干扰我们通用的业务处理。

在这里边，我们专门用udp socket绑定了8080端口啊，或者说是我们可以绑定其他的这个心跳端口。在这里边专门来接收心跳消息，这是。当然，这里边要带上user ID。这是张三一的这个。消息类型呢？message type消息类型就是这个。heart heartbeat对吧？那么，服务端接收到这个张三一发来了一次心跳消息，就会把他的这个心跳计数。怎么样哎？

减一。对了吧啊，每过一秒呢，它再去发一个hello beat它再去检疫，那也就是说正常的情况下，实际上我们用户的心跳应该是在负一。啊0到1之间其实不断的变化啊啊，你这儿的计数起来了，加一那我这儿。来了一个心跳就要减一。对不对啊？来个心跳就要简易，如果你在这里边实时的发送了心跳。实时的发送了心跳，那么我们服务端这里边呢？

对于账号的心跳计数是不可能超过五的。是不是如果说啊，以这样的机制呢，我们就可以预防当网络拥塞严严重。网络拥塞严重，我们客户端这一边的消息已经是无法到达这个chats ever端了，那么也就意味着心跳消息也没有办法到达chats ever端了。这样一来。这个chat server启动的这个心跳计时器，它每超时一秒，把账号的心跳计数加一，总会加过超过我们预定的这个心跳计数的一个预值的。超过这个预值，我们就判定了这个客户端已经掉线了，实际上如果超过这个预值，

那说明此时的网络情况确实是非常非常的差。对吧啊，可以认为呢，这个客户端已经不在线了，因为此时你发消息根本就过不来了啊。也有可能发生了这个。网络啊，风暴对吧啊，导致这个消息还回了消息过不来，到不了我们chat server了。这就都是你网络环境的问题。大家注意，这就是一个我们普通的实现的这个心跳的机制，一般呢，我们CS啊CS这种基于长连接的。

基于长连接的。业务啊，都会去实现，都会在我们业务层面去实现一个心跳，保持心跳保持机制的啊。用来监测呢，我们的这个。对端是否依然还活着呢啊？还在线。大家看一看这个能否明白呢？这就是我们所谓的心跳机制，我们在面试的时候，如果被问到。网络拥塞严重check server端如何感知客户端在线还是掉线了？我们可以给出这个新调机制的一个解决方案。

那其实有的同学也提出来了，另外一个问题就是说啊，他看过TCP协议。那么TCP协议里边啊。协议本身啊，协议这个是在哪一层啊？是在传输层对吧？在我们应用层的下边啊，在我我们上面说的这个就是在我们应用层业务上自己实现的这个心跳机制啊。这个传输层TCP协议，它有一个keep。keep alive的功能。也就是说，什么饱和功能？它这个功能是干什么呢？

因为。大家知道这个tcp协议啊，它本身是有缺陷的啊，所以它需要加上这么一个功能来弥补它的缺陷，什么缺陷呢？也就是说，像我们前边呃说的你TCP客户端跟服务器连接成功了以后啊，当你们连接成功了以后。对吧，那么这里边会涉及一个问题。连接成功了以后，如果说是这个端跟这个s端不交互，不发信息的话，一直这个呃连接链路保持这个空闲。那么，

对于s来说，那么它。到底怎么去理解c的状态呢？是c是？在线这个连接还有效，只是c确实没有说话，还是说c已经掉线了啊，但是。他没告诉我，由于网络问题，他我我得不到他的这个通知啊，就像我们大家打电话一样。突然呢呃，电话里边都保持沉默了呃，你肯定不会继续说了，

你肯定歪歪两声，因为你也不知道对方在线。在听着呢，只是没有说话，还是说对方已经掉线了啊，这个通话链路已经产生问题了，对着没有啊，对于你接收端来说的话，你没有办法去感知所谓的。事先创建的这个连接啊，当它里边一直静默的话，到底这个连接还有没有效？这个应该大家都能理解吧，所以我们TCP协议里边增加了一个keep alive的这么一个功能，但是首先同学们。

这个功能我先给大家介绍一下啊。首先呢，这个keep alive是在传输层啊，传输层添加的这么一个功能，不是在应用层跟我们应用层没有关系啊，应用层没有关系。那么在这里边。它有一些参数啊。我一个一个来说。首先，keep live功能。默认是关闭的。默认是关闭的。当我们去创建一个TCP的这个listen socket的时候，啊啊listen socket的时候，

那么在这里边，我们如果想启动它的一个keep lab的功能，我们是需要通过这个。set sock opt啊啊来打开它的这个so。keep l功能的，也就是说你要使用它，首先这个功能默认是关闭的，并没有打开啊，其打开了以后呢，他做的事情是什么事情啊，他做的事情在这里边。keep live系统配置里边啊net IPV 4 TCP keep live有三个重要的配置，首先这一个配置TCP keep live time。这个是什么？这个就是它默认的。

默认的。默认每隔。7200秒就是两个小时啊。会发送一个空的。报文段。就是消息没有没有消息体消息体是空的，它只是发一空的报文段啊探测。对方是否在线？那么，如果对方在线的话，对方会回一个啊，响应对方，如果没有去回复的话，那怎么办呢？那在这里边呢，

每隔两个小时发送一个空的探测的报文段，如果对方回复了，那就证明了这个对方还在线啊，这个链路还是有效的。那就继续静默吧，你要是不说话啊，你要是想发送消息，你可以继续在这个链路上发送消息，对吧？如果说对方并没有响应，那么在这里边呢？你注意啊。就是这个了。interval就是间隔嘛，是吧啊？

那如果探测。没有响应，那也就是说呢，可能这链路是真出问题了，也有可能呢呃，当前的这个网络环境啊。这是嗯，比较拥塞，导致我刚才发的这个探测包呢，对方没有收到，或者对方收到了回复的响应，导致我没有收到，对吧？都有这样的可能。那不管怎么样，

反正结果是我没有收到，我没有收到的话，在这里边呢啊，延迟。这里面默认的75秒。继续发送怎么样？探测包啊，饱和的这个探测包。好不好啊？那如果响应了就OK了，那就证明你在如果没依旧是啊，没有响应的话，在这里边同学们。cable live pro probes problem有问题了是吧啊？如果一直没有响应，

那在这里边最多啊，重新。探测。九次。如果都。没有响应。那么，拆除连接。那就证明这个连接确实是死掉了。那么也就是说在这里边啊，我们可以总共啊，总共在每隔两小时以后呢，总共还可以。等这么长时间，就是最长75×9啊，

这么长时间，如果一直没有响应的话，它就把连接就拆除了。好了吧，首先呢，当然这个参数是可以改的，这个参数是可以改的，你可以把这个这个这个时间调小一点。好吧啊，调小一点。那么，在这里边，首先呢？这个如果是真真正正，你靠TCP的keep live功能来实现保护功能的话，

在这里边连接，如果中断的话，同学们这是在传输舱的。这是在传输层呢。实现的keep live呀，传输层只能在在这里边把TCP的链接拆除，但是实际上我们。在业务层上，一个chat server检测到一个chat client下线了，仅仅只是把一个socket fd给它关闭掉吗？我们没有其他资源可释放。肯定不可能吧，在我们的这个业务上，我们是不是还记录这个人对应的一个connection的一个对象存在了一个什么里边啊？存在了一个map表里边。

就诸如此类的一些信息，我们都要啊，这个当这个客户端下线了以后，我们都要从我们业务层里边的各种各样的表里边啊，各种各样的这个容器数据结构里边。把这个用户相关的数据是不是全部要删除掉啊？如果你在这里边只是依赖了TCP传输层的keep live，在这里边只是关闭fd啊。而我我们业务层上啊记录的这个客户端资源只是记录了socket fd吗？这不可能了吧。是不是啊？其次，在这里边啊，用这个不可能说是依赖这个的，因为这个是我们传输层的，

传输层的上边才是谁？传输层的上边才是我们的应用层。假设我们应用层现在呢，已经运行的时候已经死锁了。应用层已经死锁了，各位应用层已经死锁了，也就是说它根本它出问题了，做不了任何的业务了，实际上已经有问题了，但实际上此时呢？死锁死锁，只是我们应用层死锁了，那我们应用层用的这个socket，它在传输层啊，传输层是属于内核了，

对吧啊，它依然是可以。和对方发送什么？发送kp live探测包的。那也就是说你在这里边呢，我们应用层已经死锁了，业务已经出现问题了，此时是此时。不管是我们客户端。还是服务器上的业务发生死锁了，此时你根本就没有办法再去交互消息了。知道吧啊，你没有办法再去交互消息了。那在这里边，如果说是客户端死锁的话，

那在这里边呢？客户端一直没有发送心跳，我们服务端应该是要判断这个客户端就跟掉线了一样。死锁了嘛，但是呢，如果客户端死锁了。实际上啊，如果业务上客户端是锁了它的，这个传输层它的TCP层，它依然是可以给。服务端发送什么？发送TCP的keep alive，因为死锁是我们应用层，死锁了我们操作系统内核，不会死锁，

内核在死锁那整个系统就怎么样？就跑不了了，系统就挂了是吧啊？我们不可能说是一个应用层的一个进程，思索了，导致我们整个操作系统都给思索了，那不可能的。所以这里边就有问题了，我客户端明明已经有问题了，已经死锁，没有办法发送正常的这个心跳消息了，对吧？没有发送，没有办法发送正常的消息了，你在这里边啊。

这个TCP传输层呢，还一直跟服务端去交互TCP的keep live呃，告诉我客户端在线，客户端在线那服务器不就比较懵了，你说你在线，那为什么你？迟迟的不给我发消息呢。是不就会产生这样的一个问题啊，所以我们一般来说呢，对于这个CS结构长连接业务的这个CS啊，但是不可能依靠TCP的keep live去保持这个。去做这个连接饱和的这么一个机制呢？大家能够明白吧。这个我刚才已经给大家说的很清楚了啊，在这里边呢，

我们一般都是在我们的业务上自己来实现一个心跳的机制。来通过呃心跳啊，保持。机制来实现呢？动态检测客户端啊，是否还在线呃？因为真实的网络环境是比较复杂的。对吧，你不可能说是通过TCP的，这个超时重传来，保证我们能够接收到这个finish包，超时重传，你是重传了，但是你重传了。你的次数的这个上限的预值啊。

你check server还是没有收到，你怎么办？那TCP只能说是把socket重置了一下。对吧啊，把所给它重置了一下。那关键是check server最终还是没有收到这个finish包啊。没有收到finish包，这个客户端已经自己重置了，那chat server一直以为这个客户端还在线。对吧啊，把这个客户端所分配的socket clan socket fd啊，没有释放相关的一些其他资源，也都没有释放。这这样来说呢，它会越多越来越多的积累这些僵尸的，

是不是客户端的这个连接呀啊？你客户端已经下线了。但是我的server连接没有拆除，所以因为心跳机制很好的解决了这个问题啊，这非常经典的一个。保护机制那么希望大家注意一下。我看还有没有啊？那这个问题相关的内容就给大家说到这里了啊，就给大家说到这里，我们大家再去。自己头脑风暴一下，我们举一反三嘛，对吧啊？举一反三啊，大家还有必要真的成个书呆子了啊，

就是老师讲到啥会啥。讲了，我们讲了某一个问题，从这个问题再想一想，其他的问题自己头脑风暴一下啊，自己头脑风暴一下啊。所以平常我们看着简历上的项目，多去想一想啊，多去想一想，多动动脑子啊。这样我们在这个面试的时候呢啊，心里也就不会慌了啊，心里就不会慌了。那好好理解一下啊，这这个问题我们就讲到