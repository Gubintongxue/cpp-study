这节课呢，我们的主要任务就是带着大家呢，把我们。这个一直以来所写的这个model网络库的重要的这个组件，再给大家总结归纳。一下啊，然后呢？我们之前嘛不是有画过这样的一张图，就是在写到这个accept or TCP server。TCP connection的时候给大家画过这样的一张图，对吧啊？那我们这节课呢，再借着这张图呢？结合我们的代码给大家把整个的这个。服务器啊的整个的这个逻辑过程呢，

再给大家去阐述一下好吧啊，描述一下这个希望呢。这个在之前对于我们整个的这个逻辑，某些细节的地方呢，还不够清楚的同学呢，听完这节课以后。能够啊，完完全全的自己呢啊，合上这些图能够自己在。智商能够画出来嗯，能够讲出来这个model库所采用的这个网络服务器设计的模型啊。然后呢？之前我们也有画过。也有画过图是吧？就是换了reactor模型，

这是给大家当时在讲reactor模型的时候啊，它几大组件啊，这些交互。只不过这个画的当然就是一个反应堆，我们相当于是有多个反应堆one路per thread对不对？啊，这是呢，我们在网络上流传比较广泛的一个基于multiple就是multithread啊多线程的，这个reactor模型。你客户端客户端May react or就是我们的May loop base loop accept or啊，这是我们的sub reactor。对吧啊，这是呢。进行相应的这个处理啊，进行相应的处理，

实际上这里边的读数据是底层做的decode decode是我们自己做的decode计算。然后是这个encode都是我们自己做的啊，从网络上读数据，然后再最终通过网络发送出去，这都是呢，由model库来帮我们做的。这些东西都是我们在on message这个函数里边是不是去处理的业务逻辑啊？唉，每一个loop对应一个线程啊，每一个线程都是一个reactor独立的reactor。好，那么大家来看梳理一下，我们刚开始呢，最开始是给他给大家讲了这个。China对吧？

我们简单的来回想一下啊，这个。China里边呢，都有什么东西？再复习一下。我们来到了channel的这个类啊channel。看成员变量。China主要做的事情呢啊。就是封装了这个fd。疑问词。跟re问题。还有一组什么啊？还有一组这个。回调我们当时给大家说了啊，当时给大家说了，

在这里边呢fd就表示呢。要往polo上注册的那个文件描述符events就是。我事先啊，这个设置的fd所感兴趣的事件，比如说读事件，写事件，对吧？r疑问词就是polo最终给我们通知的。最终给我们通知的。你这个fd上发生了什么事件？根据相应的事件呢？来执行相应的什么哎，来执行相应的这个回调。好吧，那也就是说呢，

对于上层来说。它对于上层来说，它如果有一个fd的话，它就会把fd打包成什么？打包成这个channel通道。然后下发到哪里去呀？下发到polo上。对吧，当然可以看到这个polo啊。polar我们当时看polar的时候，我们知道啊polar有一个成员变量叫做channels啊，channels是一个map。键根植键是什么键？就是channel所打包的这个sock fd。值对应的就是包含这个fd对应的，

这个China也就是说呢，如果polar。检测到哪个fd有事件发生了？然后呢，它就可以通过发生事件的fd通过这个表找到这个fd对应的这个channel。这个China里边呢？诶，这个channel里边是不是就记录了？这个详细的。事件回调啊有。都毁掉。有写回调，有close回调，有error回调。没问题吧啊channel跟这个polo呢？

是独立的啊，他们不能够直接互相通信，他们都是。依赖谁来通信呢？唉，依赖这个event loop来通信的好吧，那也就是说China跟。channel polar跟epo啊，在这里边。大家注意，这里边有这个简单写一下，有fd。还有events。还有他。这个最终发生的这个事件，

是不是还有一系列的什么call backs？这就是China。polar呢，大家刚看到了啊，这个polar。polo底层呢，主要就是你看不管是China哇，还是polo是不是都有一个成员变量记录他所在的什么？它所在的是不是这个事件循环啊？我看polo跑哪里去了，在这儿是不是也有唉，也有它有一个什么，它有一个channels。这样的一个channels。OK吧，

它有这样的一个东西啊，这样的一个东西那么简单来说呢，你看简单，如果我们在描述的时候，我们就说model库呢。不管是这个监听用的listen fd，还是accept返回，跟客户端连接呃，客户端连接成功呃，返回一个跟客户端专门通信的connection fd的话呢？都会把这些fd打包成一个China。对吧啊，给他写入呢，这个fd感兴趣的事件读或者写。是不是啊？

然后呢？把它注册到注册到相应的这个路普的polo上去。对不对啊？polar呢？实际上呢？我们在这个实例里边主要实现的就是一个epoolar啊，底层就是个e pool。啊，也就意味着呢，我们底层就是通过epo control呢，把相应的这个channel里边包含的fd注册到epo上。当epo返回以后呢啊，因为polar里边有这样的一个成员，就可以通过sock socket fd找到它所对应的channel。是不是来调用相应的这个回调啊？

啊，那么。这些channel的call backs是谁给设置的吗？肯定还是上层设置的嘛。对不对啊？肯定还是上层设置的，我们总共就有两种China嘛。我们总共就有两种China。为什么说总共只有两种拆呢？因为我们总共只有两种fd嘛，一种是listen fd。依赖于谁的啊？accept or的一种就是什么已建立？连接的客户端。专门通信用的connection fd。

啊，对于这个来说呢，它封装了一个什么呀？封装了一个。acceptor acceptor.China应该是这样拼的，对吧啊？大家有印象这个呢，是封装成这个就封装成，相当于就是connection。哎China。对不对啊？它有相应的channel。那相当于channel在调用相应的这个事件，回调的时候呢嗯，

比如说是listen fd发生的这个事件，那么它所调用的回调函数肯定是accept or塞给它的。啊，如果是已连接用户的，这个fd发生的事件肯定就是TCP connection，是不是c给我们这个channel的？要搞清楚它的这个关系啊。那么channel跟polo之间，他们能够互相访问吗？不能啊，不能，他们都是怎么样啊？他们两个都是依赖于这个event loop的是。事件循环的这个相当于就是我们的谁？reactor.

啊，这个相当于就是谁？这个相当于就是这个组件。相当于就是这里边的事件分发器。好吧，来我们到这个event loop上啊，event loop上。大家看一看。这个我无关紧要的，我们就不看了，首先呢，它有一个active channels，这是一个vector。这里边相当于包含了所有的什么，包含了所有的channel，

是不是啊？包含了所有的channel，因为你上层呢？你给这个反应堆交给反应堆的时候，交的不只是单纯的这个fd，因为反应堆到时候呢，获取到你哪个fd发生事件，是不是还要执行回调啊？所以我们塞给它的都是channel，所以它保存的是一系列的这个channel啊，它里边还有一个非常重要的就是什么？不要把这个忘了啊vkfd。好吧，这个wake fd啊。就这两个。

注释，我们就不要了。就这俩。很重要的，这俩的主要作用是什么呢？你看wake up fd呢，也是被封装成了一个wake up channel。它的主要作用就是。一个wake up d，一个wake up fd是隶属于一个谁的呃，是隶属于一个这个路普的。也就是说，每一个路普都有一个wake up fd，当我们因为路普最终执行的时候，它驱动底层的事件分发器，

也就是说驱动底层是一个。只要没有事件发生，相应的路普线程是不是一定是阻塞在这个e上的啊？那么如果我们。想唤醒某一个路普所在的县城的一个阻塞状态，那么我们直接啊，通过这个路普对象获取它的wake up fd直接。往这个wake up fd上去写个东西。相应的，路普就会被唤醒，因为呢？每一个这个loop的这个wake up fd也封装成wake up channel注册菜，注册在了自己loop的。底层的这个。一铺上就事件分发器上好吧啊，

就是你通过给这个写个东西，你就可以唤醒这个路铺了啊。还有什么东西吗？你看基本上那就是再有一个就是一个polar了。那我们从大的方向看来说的话呢？reactor啊，这个event管理的就是一堆的channel跟一个polar。是吧啊，再者就是一个wake up fd。这样一来呢，China想把自己呢注册的。polar上或者说是在polar上修改自己感兴趣的事件。是不是啊？那么都是可以通过China，都是通过event look获取polo的对象来向polo里边进行设置同样的。

polar监测到有相应的事件呃，socket有相应的这个事件发生。然后通知通过event loop。通过这个event loop啊，在这里边呢，我们就可以调用什么呢啊？调用channel相应的。这个fd所发生事件的一个回调函数。是不是啊？他们是他们三个是仅仅。相连的啊。这个注意一下。这里边大家在写的时候呢，还看到它里边有一个vector存了一堆的什么，存了一堆的这个回调函数是不是啊？

因为呢？呃，有些回调，因为这些回调就是。每一个回调啊，每一个回调在执行的时候都应该是在路普自己所在的县城。是不是去执行啊啊？那么如果说当前县城调用了路普的这个，让这个路普执行回调。在我们程序逻辑上，我们都判断了如果当前这个线程就是对应的这个loop，那么直接执行回调，否则的话呢，就把它存到一个vector里边来，然后唤醒相应的loop。

去这个vector里边拿相应的回调进行一个执行。是不是啊？这个我们当时呢？逻辑也都给大家说过啊。这就是它们三个之间的关系，我们给大家又简述了一下啊。接下来看上边的这三个。thread主要是底层的这个线程啊。是事件。线程event loop threat poll。这是一个事件。这个事件循环线程池。它里边有一个get什么next loop？这个默认就是通过轮询。算法获取下一个。

sub loop.对不对？如果没有，如果没有创建过萨普鲁，也就是说我们客户啊，没有通过set十二点number呢？来设置过这个线程，那么get next loop永远返回的都是谁呀？永远返回的，是不是就是那个base loop啊？我在这里边就简单的罗列一下，就不写全了啊。那么，当我们通过number去设置底层的这个线程数量的时候啊，event就会驱动。

就会驱动底层开始创建线程，一个线程，一个loop。一个thread。对应一个。路途就开始执行了。这就是我们所说的这个one loop。per什么thread？在这里边就是这样实现的啊。你看event loop thread po，它里边有1 base loop啊，有loop thread对吧？还有loops。还有looks。那在这里边event这个。

lp sri，这是具体的这个线程。你看包含了。底层的这个现成模型啊，在这里边start路呃。斯达尔洛普开启一个这个事件循环，这里边就启动新线程，启动新线程的话，这就是线程的执行函数，你看在。在这里边儿，每一个线程就创建了一个独立的event loop。开启当前路谱的事件循环。是不是就每创建一个子线程，就给你个loop啊，

做完相应的这个初始化操作，相应的操作以后呢就？就开始了apple weight。对吧，这就是这几个。那么。accept or在这里边儿主要封装了什么？主要封装了。就是listen fd相关的操作都有什么呢？创建内存fd绑定。socket创建band绑定，还有listen。内存成功以后呢，就把这个accept or这个。就是那个listen fd打包成这个accept or channel。

是不是扔给谁啊？扔给贝斯杜普来监听他的这个事件。大法呢，是以缓冲区。缓冲区。对吧，我们说呢，对于lo呃nonblocking的这个l呢，我们都需要设置这个缓冲区啊，因为这里边涉及了这个应用。应用写数据。写到哪里呀？写到缓冲区。再写到TCP的这个。这个发送。

啊，发送缓冲区。s in的数据是这样的一个过程。是不是啊？那么，相当于就是我们写数据，如果没有这个缓冲区的话，就是我们应用可能写的数据比较多啊TCP的缓冲区。这个写满了，就要发送，写满了就要发送。是不是啊？写满了就要发，写满了就要发送，这是一个同步的过程，

可能效率就会比较慢一点。那如果有缓冲区的话，我们应用要写数据的话呢，我们直接呢往缓冲区里边儿进行写就行了。你还记得没？这缓冲区里边呢有。首先有一个应该是prepend able。是不是还有一个reader index，还有一个什么writer？index.对吧啊，刚开始呢，这个perpend able是八个字节，刚开始呢，reader index跟writer index都是在这个八个字节处啊。

然后你写写好的东西就可以是代发送的东西。对不对啊？由我们buffer呢来专门进行，再从缓冲区读取数据呢进行发送啊。呃，我们呢？从缓冲区可以进行send发送应用呢？同时呢，还可以向缓冲区里边是不断的去写数据啊？都是通过这个reader index writer index来进行处理的啊，我们通过它的这个源码的注释，我们也知道呢。它是模仿了这个JAVA里边儿的一个。不错的网络库，就是net网络库底层人家提供的这么一个China buffer。

这个缓冲区来实现这种思想呢？我希望大家还是能要记住一下啊，以后有相类似的这个设计场景的话呢。还是可以直接用的啊。TCP connection，那这里边就是一个。一个连接。成功的。客户端。对应。一个什么？TCP.connection好吧，这个TCP connection里边呢？包含的东西呢？

有哪些呢？回想一下，这应该是我们刚刚写过的啊。由于socket由于channel，这是一个channel对吧？还有一系列对应的什么对应的这个回调？还有一个高水位线的控制啊，不要发送的过快了，是不是一个发送，还有接收缓冲区？没问题吧？一个封装了一个socket，还封装了一个什么channel，还有各种这个回调。啊，

因为我们当时说了嘛，对于这个connection的，这个fd在channel上执行回调的时候，这些connection fd的回调都是由谁来设置的？都是由TCP connection来设置的。好吧啊，还有发送和接收。缓冲区。那TCP server。就是总领所有的了。我们来再回忆一下TCP server的这个成员。啊，这成员首先他有一个什么accept or对吧？acceptor acceptor.还有谁呢？

event loop thread pole。啊，对不对？accept得到新用户啊，才能通过这个get next loop嘛，才能把这个新用户封装成TCP connection。设置各种各样的这个回调以后呢，才能选择一个萨普路普，把这个新的connection是不是扔给相应的这个路普啊？然后呢，就是一堆call back嘛。其实就是connection的一个map了。啊，connection的一个map。好的吧。

大家在这里边儿。看一下啊，看一下我们呃这一块儿呢，主要是怎么样啊？把我们写的组件它的这个成员呢？大致给大家梳理了一下他们之间的关系，主要所处的角色作用啊，给大家再复习了一下啊。那么，接下来我们就结合着这个源码。我们写过的代码，再结合我们之前画的这张图，把整个的这个流程再给大家。叙述一下。希望大家用心。

呃，把自己脑子里边记得。也相应的梳理一下，记得对的话呢，加深一下印象，记得错的话呢。修改修改啊。首先我们再来看一下啊，这个用。再来一起回忆一下。用的话，我们首先定了一个，这就是那个对吧？一个打包了IP地址端口号。然后创建了server，

把这个给到谁？给到这个echo server的构造函数，然后呢，通过这个参数来初始化它底层的t cps ever对象，相当于这里边创建了一个t cps ever的对象，对不对？然后保留了路，设置了两个什么，设置了两个回调。对吧啊，这个connection call back跟message call back。设置了一下底层的这个loop线程的这个数量。这个数量不包括base loop。okay吧。呃，

这也就很好的把这个网络代码呢，跟什么跟业务代码是不是分离了？我们只需要作为开发者，只需要关注on connection方法。这里边儿会响应连接的建立跟断开，这也会响应呢？读写事件。设置完了以后，我们电工磁带的。启动这个路谱。那也就是说呢，里边主要的这个过程呢，就是这几个啊，首先是。构造TCP server对象设置这个回调，

然后设置底层的这个路谱线程的这个数量啊。然后呢，再利用这个start方法，最后呢，开启这个主线程，这个路谱。是不是好？那么大家来跟我看一下啊。TCP server，它的这个。构造TCP server的这个构造。都做了哪些事情？核心的事情是哪些事情？首先，创建了accept or。

是不是创建了accept or啊？跟它这两个这两个那就是尤其重要了。是不是在构造函数里边，你的眼睛应该是看这一行这一行？跟这一行。首先accept accept or这个对象啊。它的这个构造函数呢？大家来看。做的事情是干什么哦？这不就是我们在创建create number blocking创建一个。非阻塞的一个listen fd嘛。对不对啊？然后呢？把它打包成一个China，这肯定是准备往这个的polar上扔的，

是不是啊？然后设置了一些TCP选项。这是不是就是绑定啊？这是创建socket，这就是band绑定。这是在干嘛呢？唉，这是呢，给我channel设置了一下，回调read call back，也就是说呢，accept channel只关心什么？只关心读事件，也就是说呢，我们在这个网络库上只关心了accept channel有新用户连接的时候。

啊的这么一个事件，它执行的就是谁access the handle read好吧啊，这里边呢我就。先不怎么样了，不再赘述了啊，我们看我们图上应该之前呢，都有给大家画。accept accept or创建listen fd。打包accept channel，然后呢？在这里边。这里边就是调用相应的这个start方法了啊。再一个创建内存fd打包accept channel设置，这个TCP选项，然后band办导完了以后设置了一个，

是不是read call back呀？唉，设置完read call back以后，大家再来跟我看啊。那在这里边就是threat p创建了一个threat p，这也现在呢，还没有开启这个loop线程是吧？完了，在这你看set new connection call back，这个是干什么的？刚才我们看到刚才我们看到啥呀？刚才我们看到。这个accept channel绑定了一个read call back，也就是说，当有新用户连接的时候啊。

它channel底层的channel是不是就会去执行什么？去执行read call back对吧？因为它有新用户连接，响应了这个epo in事件啊，就会执行这个read call back。那么，对于accept or China的read呃call back执行的是什么？执行的就是这个accept or handle read嘛？那点进去以后呢？我们发现呢？哦，你执行的就是一个new connection call back这么一个回调？这个回调是谁设给设置的呀？复活掉。就是这个set通过set new connection call back设置的，

给cter设置的，那谁给他设置的啊，我们看谁管理accept or的嘛tcb server嘛？对不对？所以我们在这个TCP server这里边啊，大家来看看。accept or通过set new connection call back设置了TCP connection，TCP server new connection。嗯，好吧，那么。这张图。来就这块啊，这块这块这块我给大家再扩展一下啊，再扩展一下。

大家来看看。给大家扩展的远一点啊，或者就是到这儿吧。这是。扩展啊，我们注释好。这是相当于就是创建listen fd，然后band啊设置这个sock。set sock option.然后干什么了？然后呢？就是执行就是赛的一个瑞的。靠。call back这个set，read callback set的就是它自己的什么函数啊？

handle read他自己的handle，read里边执行了一个new。connection.call back他的这个new connection，call back是谁给他设置的呀？我再反过来。往下画。这个是不是就是？TCP server.的构造函数中唉，设置了ac accept or。set new connection.call back.设置的是哪个函数啊？设置的就是这个谁？

就是TCP server的。new connection嘛。那我们最终也就知道了啊，我们最终也就知道了这个注册在这个上的accept or。当有新用户连接。连接成功以后呢，它经过这一串最终调用的是谁呀？有新用户连接啊，最终想的就是TCP server的new connection方法。好吧，有。有新用户连接是不是唉？响应的就是这个。最终响应的就是这个。这个能够理解吧。

唉，最终想的就是这个。那么，这是我们先把这一串说了一下啊。你看到这就完了。那接下来是干什么来着呢？接下来就是从使用的角度来看，接下来就是设置什么设置call back，对吧？设置call，call back以及threat set threat number这个呢，都没有什么，就设置个成员变量而已，就设置一下回调。是不是接着就是start了？

那我们来看一下它的这个start啊，它的这个start。首先呢，通过了一个atomic变量来控制了一下。好吧啊，来控制了一下。那么。在这里边儿，我们最开始是没有初始化，在这里边儿初始化了一下，控制了一下，只能去启动一次，对不对？这两句那做的事情来说，相对来说还是比较多的啊，

还是比较多的。首先第一个s就这个。这一句话。我看啊，这是第一个创建TCP server对象构造。这个我们就写到这儿了啊。圈起来吧。然后再来第二个就是start。start这个方法调用。start方法调用首先呢？看这一句。看这一句，这是启动底层的这个线程池是不是启动底层的这个线程池啊？唉，启动底层的线程池。

这个启动以后呢？那做的事情是什么事情呢？那就是启动了底层的什么？那这个操作。启动相当于就是创建。loop子线程。并开启。路普的。loop没问题吧，这已经start了啊子线程创建的时候呢，大家来跟我看一下啊子线程创建的时候啊。他是。子线程创建起来，执行的就是这个什么东西呢？你看看啊。

这1 start，这1 start，底层执行的就是执行的，就是一回调，我们设置的这个线程的这个回调方法就是这个。你看创建一路。在这里边，马上是不是就启动了？啊，马上就启动了。画的吧啊，启动了。注意启动的时候呢，为了能够把处在睡眠中的这个萨布鲁普给唤醒，每一个路普。

都有一个什么呀？唉，每一个loop都有一个wake up fd注册在了相应这个loop子线程的这个polar上。好不好啊？那这就说了啊。接着呢，我们再来看。start第二句。star第二句就是路普。就执行这个方法，就执行accept的这个listen方法啊。第二个呢，就是执行。ept or.ept y accept的。

内存方法。好吧啊，那这个类似的方法呢，就是我们这里边儿写的就是accept channel enable reading，相当于就是把accept channel怎么样了？注册在mel up的这个polo上了。是不是啊？注册在煤炉的托轮上。这做的事情就是把。accept or.channel channel注册在。这个贝斯路普上。那么，这不都一切都准备好了吗？是不是唉？

一切都准备好了，然后呢？最后一句就是开启，谁开启这个base loop？最终呢，就是。开启，开启。base loop的loop。好吧，这就是。我们在调用的时候。的这三步应该算是啊。构建TCP server对象。是不是同时呢？

包含了注册回调。还有set three的number的个数。这边做的事情是这么写。第二个呢，就是start start做的就是开启了。子线程的这个路普路普子线程。注册wake up fd。啊，能够让主线程就是没路普来唤醒这个子线程的这个路谱。第二就是accept or listen，把listen fd打包成一个accept or channel注册到这个base loop上。OK吧啊，然后呢，最后再启动这个路普。我们看一下这个accept的这个listen。

就这个样子。从整个的使用的这个角度来推进，我们推出来，我们整个的这个model库服务器端。它的这么一个。模块的组织方式。这个应该能够明白了吧，注意它的梅鲁普跟这个萨布鲁普中间有没有同步队列啊？没有同步队列。并没有使用消这个生产者，消费者模型，我们路普来生产链接放到这个同步队列里边儿，我们萨博路普呢，从同步队列里边儿。去自己去取，

做成一个异步的生产连接跟消费连接，对吧？没有啊，而是呢，用系统调用event fd。创建的这么一个wake up fd。唉，可以用它直接来做什么？直接来做线程间的note five。就是通知唤醒效率是非常非常高的。大家注意。在这儿学到的这个系统调用。在lab event上呢，用的是。socket pair.

socket pair这样的一个系统调用啊，创建的是一个基于unix本地通信的一个双向通信的一个套接字。好，那在这里边呢，我们继续来看，现在有一新的连接了。有一新的连接的话，那么我们说。是不是就返回了？返回执行accept channel相应的一个读是读的这个read call back。那read call back最终呢？调用的就是TCP server，是new connection，就是有一条新的链接来了是吧？那有一条新的链接来了以后呢？

我们就看我们的这个TCP server，这个new connection嘛？他做的事情是什么事情？首先根据轮询算法啊，选择一个sub loop，让我这个l loop指针指向。是吧，接着呢。这些无关紧要的，我们就不看了啊。接着做的事情呢，就是创建了一个什么，创建了一个TCP connection对象。啊，创建了一个TCP connection对象，

并设置了什么它的？相应的回调，这些回调呢？将来，由TCP connection就设置到谁里边去了？就设置到它底层的谁，它底层的channel里边去了嘛？对吧啊。重要的还是设置了一个什么啊close call back。当fd被关闭的时候呢，这里边就最终回调到了TCP server remove connection。记住，刚好是一对应的，有新连接来了，就是TCP new connection连接关闭了，

对应的就是TCP server的这个remove connection。好吧，最终执行了什么？最终执行了这个l loop running loop的。这么一个方法执行这个。那么，同学们注意啊，这个l路普呢？你看当前的这个new connection，这个肯定是在我当前的这个主线程里边去执行的嘛。在主线程里边，你访问这个l肯定访问的是一个。子线程对应对应的一个子线程的一个loop嘛，所以呢，在这里边l loop执行的这个running loop肯定不是在我的什么肯定不是在我的主线程里边。

当然，也有例外，什么例外呢？就是我没有设置过子线程，我没有设置过set number这个l loop，永远指向的就是base loop。那当然，这个l loop base loop就永远在主线程当中，running loop，running loop实现的这个逻辑就是。如果说是你，路普就是在当前的县城里边儿直接执行这个回调，否则的话，是不是坤应路普啊？大家能理解这里边儿的意思吧，

如果说是我没有设置过，那么没有设置过sub里边儿呢，那就直接是执行这个回调。否则的话呢，这里边儿就是昆英路普昆英路普的话，就是因为每一个l路普每一个疑问的路普都有一个成员变量什么？就wake up fd嘛，这里边呢诶，我要在一个sub look里边执行这个方法。那我就通过这个指针找到这个sub loop的wake up ft，往wake up ft上去写一个数据。把相应的这个subl up是不是就给唤醒了？唤醒以后就去执行这个connection，establish。那么在这，

我希望再画一下啊。我希望再画一下。new connection干嘛呢？在这里边儿啊？选创建。TCP.connection对象。注册回调。对吧啊，然后呢？包括这个close回调啊close。这里边儿我们单独写写一个close的这个回调，对应的就是TCP server的。嗯，对应的是谁呀？

TCP server remove connection啊，remove CON ection。对吧，轮询算法选择sub loop。用谁来指向啊？用LOL oop来指向的。那么最终呢，再调用，再通过l loop。调用它的这个run in loop。最终执行哪个呀？执行就是TCP connection的。TCP connection里边的哪个方法呢？各位得往下写了啊。叫做这个connection。

connect established.好的吧啊。那到这了，那就是连接成功以后。接下来做什么事情，我们就进到这个里边，看这课的时间稍微有点长，我们这节课就先说到这里，下节课我们继续啊，来梳理这个流程。