好，各位同学呢？我们再来看这个lO的异步。

lO的异步在这里边，我们就不能够用receive来举例子了，因为receive是一个什么接口啊，是一个同步的IO接口。

好吧啊，它跟send一样，都是同步的IO接口。

## IO异步概念

好不好？我们要来告诉大家什么叫lO异步，我们先从抽象层面来给大家说一下，肯定跟刚才的情况不一样。对吧啊。

那么，在这里边儿啊，所谓的异步就是当我请求内核的时候,

内核啊，我现在呢，比较关心这个sock fd上的数据。远端如果发过来数据的话呢？

唉，我对这个socket fd上的数据我非常感兴趣，我需要读它接收到的数据，对不对？

那在这里边呢，我有一个buf。这个buffer是干嘛的呢？呃，这个buffer就意思是说呀，就是说到时候有数据来的话呢，你能不能帮忙把这个数据直接放到这个buffer里边？好吧哎，直接放到这个buf里面。

然后呢？你别光放啊，你放完没放完，我也不知道啊。

而我再给你注册一个这个lO信号。

那也就是说呢，你看啊，对于一个异步的lO接口的话呢，操作系统的异步的lO接口的话呢？

它有这么一个操作，就是我首先呢，调用你这个异步lO接口的时候，我就会先塞给你一个sock fd，因为我对这个sock fd上的事件感兴趣了。

对吧，它如果上面的数据可读的话，我麻烦你给我把数据搬到这个buffer里边，

### IO异步接口是麻烦操作系统帮我们从内核中sockfd对应的TCP缓冲区搬到应用程序的buffer

你注意我是麻烦谁呢，我作为应用程序，我是麻烦操作系统给我搬到buffer里边。

刚才的同步lO是谁办的？是应用程序是不是自己调用这个同步lO接口，把时间花到这儿，自己是不是搬的对？

你搬完你,你这个内核在这里边，把这个内核缓冲区啊，这个socket fd对应的TCP接收缓冲区的数据呢，搬到我这个buffer里边来，以后呢，

搬完以后。麻烦你给我应用程序通知一下，你通过一个信号给我通知一下对不对呃，然后在这里边儿。我就可以应用程序啊，玩自己的。做任何事情都可以。

### 当我们调用异步IO接口时，应用可以继续忙自己的事

当我们调用啊，这个异步lO的时候呢？异步IO接口的时候啊，当我们应用程序调用了这个异步lO接口的时候。

我们就把这三个都塞给了这个操作系统。

对吧，我应用程序就玩自己的了，想做什么事情都可以，你想睡觉也可以，或者说是你做一些其他的一些耗时任务也可以。

对吧，读数据库啦，读缓存啦，任何事情都可以。

关键是你不用像刚才的lO同步一样，在这里边一直在这,要么是死等的receive这儿，要么就是在这儿玩儿空转(非阻塞情况)是不是你完全可以玩自己的了？

当操作系统通知你的时候。这个lO通知。来通知你的时候。你看到的是buf的数据已经准备好了。



### 不论是操作系统的异步IO还是并发的异步，都有一个特点是会有通知

那么，在这里边，同学们注意一下啊，我刚才在这个课程里边说了，不管是我们操作系统。这个角色的lO的同步跟异步，还是我们在聊应用程序的并发的同步跟异步的时候，

我们说啊。在这里边儿，他们的核心的理念都是一样，异步在这里边儿，你一定需要注意一下这个词语，你给我把它记住了。通知这么一个特点。是我们异步最大的一个标识。

好吧啊，==是异步就得有通知，有通知它就有可能是一个异步操作==。

在这里边，我们来对比一下。刚才在同步的这个IO的这个调用的时候。

有数据准备好了，我们在这里边数据是自己搬的。是不是自己花时间办的？

哎，费了老劲了，把这个搬完以后，我们receive呢，才返回的。在从内核的TCP接收缓冲区，把数据搬到我们。用户态应用程序的这个buffer缓冲区里边。

这个耗的是我们应用程序的时间。这时间是算到我们应用程序的。好吧啊。

### 异步IO接口不仅可以通过信号还可以通过回调

在这里边看，这相当于是当我调用操作系统的异步lO接口的时候，我把相应的socket buffer跟通知方式。在这里边，我告诉你的是通知方式，因为同学们这通知不仅仅是通过信号啊，对不对？还可以通过回调啊。回调你不要忘了。

这是非常这个重要的一种。通知方式啊，回调啊，

在这里边我们用的是singal啊。把这个通知方式buffer跟sock fd都通过呢，异步lO接口传给操作系统。

### 交给操作系统，应用程序自己做自己的事

我现在应用程序就玩自己的了。当我应用程序得到singal的一个通知的时候。

我这数据用不用应用程序，自己从内核的TCP接收缓冲区里边搬到我的用户态的这个应用程序的buffer里边呢？

用不用花我应用程序，自己的时间用不用花？

肯定不用花，这已经画的很清楚了。对不对？

### 类比买机票

再说通俗一点，就是我们大家想去旅游买机票。

这个同步lO在这里边，相当于就是唉，数据准备好了，反正你这个机场告诉你机票已经出来了是吧啊，

那么同步IO相当于就是你自己从你的家里边打个车，或者你坐什么车？跑到机场自己去取这个车票去，自己去取这个机票去。取机票的这个过程花的是你自己的时间啊。对不对啊？那么这些相当于是什么呢？这相当于就是。操作系统，人家有没有给你提供这样的服务？

那也就是说WINDOWS系统或者Linux系统，或者说是MAC系统，对吧啊？有没有给你提供



异步lO接口让你调用你将机场哎票出来了哎，机场通过叫了一快递员对吧？帮你把票根据你。事先留的这个地址啊，给你送到你门口了，快递员通通通敲你门。你知道票来了，是不是当你打开门，你根本就不用打车，

你也不用坐什么车出去？你直接开开你家的门儿，你就看见这个机票在你眼睛跟前儿闪过来闪过去，你已经拿到票了。

哪种效率高啊？异步IO嘛。

是不是啊？异步效率确实高。

但是呢，它编程复杂。是吧啊，你看我这同步lO，我就调用receive，你看你这异步接口，你问我要了多少东西？

这还涉及一个通知。啊，你得到通知以后呢啊，我再去做接下来的事情，对吧啊？

从这个实现方式上来看。从编程的这个复杂程度上来说呢，这个异步lO接口的这个编程方式肯定是要比同步要复杂一点。对不对啊？

但是得到的这个效率高啊啊，但是出问题也不太好排查，对不对啊？

在这里边呢。你像我们著名的这个。什么东西呀啊？一会给大家再揭晓啊，一会给大家再揭晓，我们先不做太多的，这个扩展啊。



异步lO接口那在这里边，我们linux的这个aio_read跟aio_write？

这就是两个啊，这就是两个典型的我们Linux内核给我们应用程序提供的一个异步IO接口。

好吧，你在这个用man可以查出来都。



read你看它需要一个aio cb，这么一个东西。结构体的数据对吧？这个我在课件上给大家也列了，这个我是本来打算给大家讲IO模型的时候给大家说。现在提前看一看也没关系啊。

你看这个aio cb就是aio read需要的，这个参数也就是在这里边，我们画的应用程序在调用这个异步l接口的时候啊。需要给他传的东西给evl接口传，那就是给内核传嘛，是不是？fields是不是有一个socket fd？对吧，

是不是还得传一个用户空间的一个buffer进去啊？你到时候内核会帮你把TCP接收缓冲区的数据搬到这个buffer里边来。



对不对？看还有啥呢？还有通知方式嘛，通过信号进行通知。没问题吧？哎，通过信号进行通知。

OK吧啊，大家呢，可以了解一下Linux系统给我们应用程序提供的这两组异步IO接口。还是不错的啊。

好在这里边呢，相信讲到这啊，大家对于这个IO的这个同步跟异步呢，应该有了解了吧？

是不是啊在？

我们聊应用程序并发的这个同步跟异步的时候呢啊，

实际上呢，这个概念是一样的啊，所有的同步就是我们在调用我们应用层，或者我们使用的第三方库啊，或者是我们自己写的库啊，对不对？一些API接口的时候呢，就跟我们在这里边lO同步的，这个表现是一样。

我要么是死等这儿等待数据可读，或者是要么在这儿空转原地空转。

啊，那就是数据没准备好，非阻塞的模式下数据空转在这儿。

等待数据的是不是到来啊啊？就是在这里边数据如果来了啊，这个数据的搬运呢，还得我自己来做。

### 再次总结异步IO的概念

==异步就是什么呢？异步IO就是我把该给你的都给你，然后我就可以自己做自己的事情。啊，到时候数据准备好了，你帮我读好，再以用我事先和你约定的通知方式，你再来通知我，我处理数据就可以==。对不对啊？所以在这里边搞清楚异步的一个非常重要的这个特点就是事先会约定一个通知方式，通过信号啊，通过回调啊，对吧？啊，当我们数据准备好了，数据读写好了，唉，我们的这个API接口呢，会给我们进行实时的通知的。这就是异步最大的一个特点。



从这一点上来看呢，也就是说呢，我们实际上啊，也没有太有必要去区分lO的同步跟异步以及并发的这个同步跟异步。好吧啊。那在这里边，你像我们比较著名的这个。

nodejs.这就是一个基于这个异步非阻塞模式下的高性能是不是服务器呀？

哎，确实是应用还是比较广泛的。在这里边，大家了解一下就行了，也没有必要去专门去学习一下，因为它是用JavaScript来编写的啊。



啊，到这里的话呢，我给大家就把这个同步跟异步的区别也就给大家介绍。

在这我隆重的给大家推荐这么一句话，就是我们muduo库的作者。

### 陈硕的解释 

啊，陈硕大臣在知乎上的原话啊。知乎上有一个帖子。对吧，让去解释这个同步跟异步。很多人都是大篇幅大篇幅的去解释啊，要解释到头还是稀里糊涂的让读者。

陈述大神就一句话啊，底下的这个网友就在留言，特别喜欢大神的这种方式啊，言简意骇。

嗯，能一个字完成的，绝不说两个字啊。这就是大神的这个特点，人家在解释一个复杂东西的时候呢啊，这个非常的言简意赅啊，不会做过多的这个废话的这个输出啊。



==在处理IO的时候，阻塞和非阻塞都是同步IO。==

==只有使用了特殊的API才是异步IO。==



你注意理解这句话，特殊的API。什么叫特殊的api啊？

在这里边，你看，你给操作系统ssocket fd，你给它c一个应用程序的一个缓冲区，你再给它c1种通知的方式。

你要知道，你这相当于把所有的事情都让内核来做。

内核最后做完以后通知你，你这个相当于内核要支持这样的功能，要想给你做，能给你做。

也就是说，内核会提供这些特殊的API呀？

咋没见Windows系统提供呢？对不对啊？

当我们调用啊，调用内核的这个特殊的API的时候呢？

在这里边才是一个异步的IO。

windows也提供异步api

啊啊，这个WINDOWS也提供了啊，在这里边人家说了lcp对吧lcp？这也有啊，但是因为我们一般不会在WINDOWS上去写高性能的服务器啊，在这边口误啊

WINDOWS上也有异步呀，在这里边陈硕大师也给大家列出来了。

在linux的aio read跟aio write这一组方法。好不好

WINDOWS上的iocp？啊iocp。net上呢，有begin invoke end invoke

好像操作系统都会提供这样的这个异步lO操作。



### 只有使用了特殊的API才是异步IO

OK吧啊，只有使用了特殊的API才是异步IO，在处理IO的时候。阻塞跟非阻塞都是同步IO。

什么叫处理呢？读嘛，或者是写嘛，等待这个sock上有事件发生嘛，是不是啊？

你像这个lO复用的这个select的一一啊，它都是什么？它都是同步的IO。

像这个epoll是同步的IO还是异步的IO的话呢？在这里边儿，大家经常会犯糊涂，它是一个同步的IO。啊，它是个同步的IO。

你看在这里边啊，给大家简单说一下。你epoll在调用的时候呢？你传参数以后。epoll wait在调用的时候。最后一个参数是不是一个time out呀？

啊，如果你不自定义时间的话，它相当于工作在阻塞状态。是不是它功能在阻塞状态？

当有事件发生的话，它会返回发生事件的这个event是不是那我们再从event上读？

而如果这个event相对应的事件就是它这个socket fd上有发生可读事件了，

我们读，我们再调用receive。

这数据是操作系统帮你读好的，还是你自己读啊？那当然，你自己的读了嘛，这还是一个同步的一个IO嘛。



okay吧啊，这是一个同步的IO吧。那这个time out在这里边，你当然可以设置超时时间，你设置超时时间以后啊，你也得检查呀。你的检查到底有没有发生？是不是这个事件的？

这个event fd没有的话呢？你是不是继续循环，继续epoll wait呀？

并没有像这个异步操作一样啊，在事件没有发生数据,没有读写完成之前，我应用程序呢，都是可以自己去处理自己的事情。好吧啊，所以像这个lO复用接口呢，尤其像这个epoll。这都是同步IO接口的。



okay吧，它跟evl接口根本没有任何的关系。好不好啊？这是操作系统给我们提供的这个接口，

所以在谈论同步或者异步的时候呢？

我们当然谈的都是IO的同步或者异步，我们再说这接口本身的是不是啊？

如果我们再说业务层面上。业务层面上的一个逻辑处理。是同步还是异步的时候。

我们也很好区分嘛啊，同步相当于就是我在同步，在这里边儿就是一直。

呃，相当于就是a。这个等待。b做完事情啊，得到返回值。继续处理。

就是a操作，等待b操作做完事情得到返回值，是不是继续处理啊？



而异步是什么呀？异步就是a操作告诉b操作，它感兴趣的事件以及通知方式，然后呢a操作继续执行自己的业务逻辑了啊。

当b监听到这个事件。相应事件发生后。b会通知a注意通知啊。

a开始相应的数据处理逻辑或者是操作处理逻辑。



大家能体会到它们的区别吧，唉，这就是它们的区别。okay吧啊。知道区别以后呢，大家如果再去了解node js的话，你会发现node js的编程非常有意思它。任何操作啊，任何操作都是传入相应的数据以及一个回调。



对吧啊，典型的一个异步。操作的这么一个过程啊，当他感兴趣的事件呢，发生以后呢，他的回调操作。会有底层的。自动的去给他调用一个异步通知的过程。OK，那么这节课的讲解呢？我相信大家应该对于这个同步跟异步应该有了一个更深刻的一个了解了吧？啊，

那么能否先自己想一想啊，如果让我去说阻塞非阻塞同步异步的话呢？在这里边，我通过学习的这几节课，我能不能说的更好一点呢？